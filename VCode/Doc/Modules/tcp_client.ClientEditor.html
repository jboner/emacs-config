<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>

<META NAME="GENERATOR" CONTENT="pythondoc 0.7 (Thu Dec 26 23:45:46 2002)">

<link rel="stylesheet" href="pythondoc.css" type="text/css">

<title>Class ClientEditor</title>
</head>

<body>
<P><A HREF="index.html">Table of contents</A> <A HREF="indices.html">Index</A></P>


<H1 CLASS="ClassName">class ClientEditor - abstract base class for handling messages to and from the client editor</H1>
<P CLASS="DeclaredIn">Declared in module <A HREF="tcp_client.html">tcp_client</A></P>

<H2 CLASS="ClassHierarchy">Inheritance hierarchy:</H2><P CLASS="ClassHierarchy">tcp_client.ClientEditor<BR>
&nbsp;&nbsp;Object.OwnerObject<BR>
&nbsp;&nbsp;AppState.AppCbkHandler<BR>
</P>

<H2>Synopsis</H2>
<PRE CLASS="ClassDeclaration">
<SPAN CLASS="PyKeyword">class</SPAN> <SPAN CLASS="ClassName">ClientEditor</SPAN>(<A CLASS="DocLink" HREF="Object.OwnerObject.html">OwnerObject</A>, <A CLASS="DocLink" HREF="AppState.AppCbkHandler.html">AppCbkHandler</A>):
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.__init__"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.__init__</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">editor</SPAN>, <SPAN CLASS="Argument">owner</SPAN>, <SPAN CLASS="Argument">ID</SPAN>, <SPAN CLASS="Argument">owns_editor=0</SPAN>, <SPAN CLASS="Argument">**args</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.close_app_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.close_app_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">unexpected=0</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.close_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.close_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_active_buffer_name</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_backspace</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_beginning_of_line</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_bidirectional_selection</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_broken_connection</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_close_buffer</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_confirm_buffer_exists</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_decr_indent_level</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_delete</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_end_of_line</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_file_name</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_get_instance_string</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_get_pos_selection</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_get_text</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_get_visible</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_goto</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_goto_line</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_incr_indent_level</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_indent</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_insert</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_insert_indent</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_language_name</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_len</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_line_num_of</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_list_open_buffers</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_make_position_visible</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_mediator_closing</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_multiple_buffers</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_multiple_windows</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_newline_conventions</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_open_file</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_pref_newline_convention</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_process_active</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_recog_begin</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_recog_end</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_save_file</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_set_instance_string</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_set_selection</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_set_text</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_shared_window</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_suspend_notification</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_suspendable</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_terminating</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_title_escape</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.cmd_updates</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">arguments</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.connect"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.connect</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">talk_msgr</SPAN>, <SPAN CLASS="Argument">listen_msgr</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.curr_buff_name_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.curr_buff_name_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.disconnect"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.disconnect</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.disconnected"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.disconnected</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.do_cmd"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.do_cmd</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cmd</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.mediator_cmd"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.mediator_cmd</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.new_window"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.new_window</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.on_change"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.on_change</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start</SPAN>, <SPAN CLASS="Argument">end</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">selection_start</SPAN>, <SPAN CLASS="Argument">selection_end</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">program_initiated</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.open_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.open_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.pos_selection_update"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.pos_selection_update</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name=None</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.rename_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.rename_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.resume_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.resume_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.send_response"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.send_response</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>, <SPAN CLASS="Argument">value</SPAN>, <SPAN CLASS="Argument">value_name=None</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.send_simple_response"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.send_simple_response</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.send_updates"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.send_updates</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">update_list</SPAN>)<SPAN CLASS="OneLiner"> # send a list of updates to the mediator</SPAN>
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.send_updates_response"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.send_updates_response</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>, <SPAN CLASS="Argument">updates</SPAN>)
    <A CLASS="DocLink" HREF="#tcp_client.ClientEditor.suspend_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">tcp_client.ClientEditor.suspend_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.Object</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args_super</SPAN>)
    <A CLASS="DocLink" HREF="#Object.Object.decl_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.decl_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Define new attributes for <EM>self</EM></SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.deep_construct"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.deep_construct</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)<SPAN CLASS="OneLiner"> # Build an instance of a class.</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)<SPAN CLASS="OneLiner"> # Initialises existing attributes</SPAN>
    <A CLASS="DocLink" HREF="#Object.Object.possibly_init_attrs"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.Object.possibly_init_attrs</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from Object.OwnerObject</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**attrs</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject._cleanup_object"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject._cleanup_object</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)<SPAN CLASS="OneLiner"> # attempt to call cleanup on object</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_grandparent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_grandparent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append a new attribute name to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.add_owned_list"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.add_owned_list</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)<SPAN CLASS="OneLiner"> # append new attribute names to the list of owned objects</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.cleanup"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.cleanup</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.name_parent"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.name_parent</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)
    <A CLASS="DocLink" HREF="#Object.OwnerObject.owned_by"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.owned_by</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)<SPAN CLASS="OneLiner"> # returns the name of the parent attribute</SPAN>
    <A CLASS="DocLink" HREF="#Object.OwnerObject.remove_other_references"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">Object.OwnerObject.remove_other_references</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>)

    <SPAN CLASS="InheritsHead"># Inherited from AppState.AppCbkHandler</SPAN>
    <SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.__init__</SPAN>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">**args</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.close_app_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.close_app_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">unexpected=0</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.close_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.close_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.curr_buff_name_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.curr_buff_name_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.new_window"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.new_window</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.open_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.open_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.rename_buffer_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.rename_buffer_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.resume_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.resume_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)
    <A CLASS="DocLink" HREF="#AppState.AppCbkHandler.suspend_cbk"><SPAN CLASS="PyKeyword">def</SPAN> <SPAN CLASS="FunctionName">AppState.AppCbkHandler.suspend_cbk</SPAN></A>(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)

</PRE><H2>Description</H2><P>
<STRONG>INSTANCE ATTRIBUTES</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM> connected
<DD>flag indicating whether we are connected to the
mediator or not
<DT>
Messenger <EM>talk_msgr</EM>
<DD>Messenger for sending commands to the mediator
<DT>
MixedMessenger <EM>listen_msgr</EM>
<DD>MixedMessenger for receiving commands from 
the mediator without blocking
<DT>
AppState <EM>editor</EM>
<DD>the AppState interface to the underlying editor
<DT>
STR <EM>editor_name</EM>
<DD>the string which the editor uses to identify
itself to the ClientEditor
<DT>
<EM>{STR:FCT}</EM> msg_map
<DD>map from message names to (unbound) methods
taking <EM>(self, {arg:val})</EM> to handle that message
<DT>
<EM>[STR] expect</EM>
<DD>list of commands expected from the mediator
<DT>
<EM>BOOL ignore_callbacks</EM>
<DD>flag to indicate that callbacks are
triggered by a mediator-initiated message and should be ignored
<DT>
<EM>[{STR:ANY}] awaiting_response</EM>
<DD>list of responses to a
mediator-initiated change, or None if we are not in the middle of a
mediator-initiated change
<DT>
<EM>owner</EM>
<DD>the owner of the ClientEditor, which should be notified
if the mediator sends a <CODE>mediator_closing</CODE> or <CODE>terminating</CODE> message,
or if the ClientEditor receives a close_app_cbk from AppState
<DT>
<EM>STR ID</EM>
<DD>unique ID of this ClientEditor, so that it can identify
itself during callbacks to its owner
<DT>
<EM>BOOL mediator_closing</EM>
<DD>flag indicating that the ClientEditor has
received a mediator_closing message, and shouldn't be surprised if
it receives a broken_connection message.
</DL>
<P>
<STRONG>CLASS ATTRIBUTES</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.__init__" CLASS="Method">tcp_client.ClientEditor.__init__(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">editor</SPAN>, <SPAN CLASS="Argument">owner</SPAN>, <SPAN CLASS="Argument">ID</SPAN>, <SPAN CLASS="Argument">owns_editor=0</SPAN>, <SPAN CLASS="Argument">**args</SPAN>)</H2>
<P>None</P>

<P>
if owns_editor is true, ClientEditor.cleanup will clean up
the editor AppState.  If not, ClientEditor's owner is
responsible for doing so.
</P>
<H2 ID="tcp_client.ClientEditor.close_app_cbk" CLASS="Method">tcp_client.ClientEditor.close_app_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">unexpected=0</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which indicates that the application has 
closed </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance to be removed
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.close_buffer_cbk" CLASS="Method">tcp_client.ClientEditor.close_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has closed a buffer</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the buffer which was closed
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.connect" CLASS="Method">tcp_client.ClientEditor.connect(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">talk_msgr</SPAN>, <SPAN CLASS="Argument">listen_msgr</SPAN>)</H2>
<P>None</P>

<P>
method to call to let the ClientEditor know that the client
has connected to the mediator, and can communicate with it by
means of the provided talk_msgr and listen_msgr.</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.curr_buff_name_cbk" CLASS="Method">tcp_client.ClientEditor.curr_buff_name_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the current
buffer has changed</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the newly current buffer 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.disconnect" CLASS="Method">tcp_client.ClientEditor.disconnect(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to call to tell the ClientEditor to send a message 
disconnecting from the mediator</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.disconnected" CLASS="Method">tcp_client.ClientEditor.disconnected(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to call to let the ClientEditor know that the client
has disconnected from the mediator
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.do_cmd" CLASS="Method">tcp_client.ClientEditor.do_cmd(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">cmd</SPAN>)</H2>
<P>None</P>

<P>
perform the appropriate action in response to the command
from the mediator</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
(STR, {STR: STR}) cmd
<DD>The message retrieved
from external editor in <EM>(mess_name, {arg:val})</EM> format
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.mediator_cmd" CLASS="Method">tcp_client.ClientEditor.mediator_cmd(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to call when the main thread receives a message
from the data thread that a command from the mediator is waiting
in the queue</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.new_window" CLASS="Method">tcp_client.ClientEditor.new_window(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us of a new window for the 
specified instance</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if window is added

</DL>
<H2 ID="tcp_client.ClientEditor.on_change" CLASS="Method">tcp_client.ClientEditor.on_change(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">start</SPAN>, <SPAN CLASS="Argument">end</SPAN>, <SPAN CLASS="Argument">text</SPAN>, <SPAN CLASS="Argument">selection_start</SPAN>, <SPAN CLASS="Argument">selection_end</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>, <SPAN CLASS="Argument">program_initiated</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState to notify us of a change to one of its
buffers</P>

<DL>

<DT>
<EM>INT start, end</EM>
<DD>character offsets of start and end of 
changed region (before the change)
<DT>
<EM>STR text</EM>
<DD>text with which that range was replaced
<DT>
<EM>INT selection_start, selection_end</EM>
<DD>character offsets of the
selection (after the change)
<DT>
<EM>STR buff_name</EM>
<DD>buffer which was changed
<DT>
<EM>BOOL program_initiated</EM>
<DD>flag indicating whether the change
was program-initiated (i.e. in response to a command from the
mediator via ClientEditor) or user-initiated

</DL>
<H2 ID="tcp_client.ClientEditor.open_buffer_cbk" CLASS="Method">tcp_client.ClientEditor.open_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has opened a new buffer </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the buffer which was opened
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.pos_selection_update" CLASS="Method">tcp_client.ClientEditor.pos_selection_update(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">buff_name=None</SPAN>)</H2>
<P>None</P>

<P>
create an update description for the current cursor location
and selection for a given buffer</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR buff_name</EM>
<DD>name of the buffer, or None for the current
buffer
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>[{STR:ANY}]</EM>
<DD>the update descriptions

</DL>
<H2 ID="tcp_client.ClientEditor.rename_buffer_cbk" CLASS="Method">tcp_client.ClientEditor.rename_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has renamed a buffer</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> old_buff_name
<DD>old name of the buffer 
<DT>
<EM>STR</EM> new_buff_name
<DD>new name of the buffer 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.resume_cbk" CLASS="Method">tcp_client.ClientEditor.resume_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us that its process has 
resumed after having been suspended </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.send_response" CLASS="Method">tcp_client.ClientEditor.send_response(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>, <SPAN CLASS="Argument">value</SPAN>, <SPAN CLASS="Argument">value_name=None</SPAN>)</H2>
<P>None</P>

<P>
send a response to a message to the mediator via the 
listen_msgr in response to a message from the mediator </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> name
<DD>name of the response
<DT>
<EM>{STR: ANY}</EM> value
<DD>dictionary with arguments of the message
<DT>
<EM>STR value_name</EM>
<DD>name to use for the value (defaults to
<CODE>value</CODE>, but occasionally <CODE>updates</CODE> is needed)
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.send_simple_response" CLASS="Method">tcp_client.ClientEditor.send_simple_response(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>)</H2>
<P>None</P>

<P>
send a simple response without any arguments to a message 
to the mediator via the listen_msgr in response to a message 
from the mediator </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> name
<DD>name of the response
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.send_updates" CLASS="Method">tcp_client.ClientEditor.send_updates(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">update_list</SPAN>)</H2>
<P>send a list of updates to the mediator</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>[{STR: ANY}]</EM> update_list
<DD>list of update dictionaries (see
messaging.py for format)
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.send_updates_response" CLASS="Method">tcp_client.ClientEditor.send_updates_response(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">name</SPAN>, <SPAN CLASS="Argument">updates</SPAN>)</H2>
<P>None</P>

<P>
send a response to a message to the mediator via the 
listen_msgr in response to a message from the mediator,</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> name
<DD>name of the response
<DT>
<EM>{STR: ANY}</EM> updates
<DD>dictionary with arguments of the updates
message
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="tcp_client.ClientEditor.suspend_cbk" CLASS="Method">tcp_client.ClientEditor.suspend_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us that its process is about
to be suspended</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.Object.decl_attrs" CLASS="Method">Object.Object.decl_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Define new attributes for <EM>self</EM></P>

<P>
Attributes are directly through self.__dict__, thus bypassing safe
__setattr__.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 initial values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.deep_construct" CLASS="Method">Object.Object.deep_construct(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">this_class</SPAN>, <SPAN CLASS="Argument">attrs_this_class</SPAN>, <SPAN CLASS="Argument">args_super</SPAN>, <SPAN CLASS="Argument">new_default={}</SPAN>, <SPAN CLASS="Argument">enforce_value={}</SPAN>, <SPAN CLASS="Argument">exclude_bases={}</SPAN>)</H2>
<P>Build an instance of a class.</P>

<P>
Basically, this method:
- declares and initialise all attributes listed in <EM>attrs_this_class</EM>
- invokes the <EM>__init__</EM> of all superclasses (with the exclusion of those listed in *exclude_bases*), passing them arguments in <EM>args_super</EM></P>

<DL>

<DT>
<EM>CLASS</EM> this_class
<DD>Class that we want to build. This is a
 class object as opposed to the name of a class. Constructors
 of immediate superclasses of <EM>this_class</EM> are called
 automatically, except if they are listed in *{CLASS: 1}
 exclude_bases*.
<DT>
<EM>{STR: ANY}</EM> attrs_this_class
<DD>New attributes (and their
 values) defined by class <EM>this_class</EM>. The keys are the names
 of the attributes and the values are the values of the
 attributes (either default values or values passed to
 *this_class.__init__*). An attribute with the appropriate
 name will be declared automatically and initialsed to the
 value specified in <EM>attrs_this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> args_super
<DD>Arguments received by
<EM>this_class.__init__</EM> but not recognised by it. These are
assumed to be arguments defined in the <EM>__init__</EM> of some
ancestor class and are just passed up the construction
chain. Keys of <EM>args_super</EM> correspond to the names of the
arguments and the values corresponds to the values received
for them by <EM>this_class.__init__</EM>
<DT>
<EM>{STR: ANY}</EM> new_default={}
<DD>Used to change the default
 value of an ancestor constructor argument. In other words, if
 <EM>this_class.__init__</EM> was called without specifying a value
 for an argument that's listed in <EM>new_default</EM>, the default
 value defined in <EM>new_default</EM> will be used instead of
 whatever default might be defined in the constructor
 of an ancestor class. However, if the constructor was called
 WITH a specific value for that argument, that specific value
 will be used instead of both the defaults defined in
 <EM>new_default</EM> and the constructor of ancestor classes. Keys
 of <EM>new_default</EM> correspond to argument names, and values
 correspond to the new default values. If you don't specify a
 value of <EM>new_default</EM>, it defaults to <EM>{}</EM>, which means that
 the defaults of none of the ancestor constructor arguments
 are redefined by <EM>this_class</EM>.
<DT>
<EM>{STR: ANY}</EM> enforce_value={}
<DD>Lists of arguments with
 enforced values. If the constructor is called with a value
 for an argument that is different from the value specified
 for it in <EM>enforce_value</EM>, then an <A HREF="Object.EnforcedConstrArg.html">EnforcedConstrArg</A>
 exception will be raised. Also, if the constructor is called
 without specifying a value for a particular argument, then
 the value defined in <EM>enforce_value</EM> (if it exists) will be
 used instead of whatever default might be defined in an
 ancestor class. Keys of <EM>enforce_value</EM> correspond to
 argument names and values correspond to the enforced
 values. If you don't specify a value for <EM>enforce_value</EM>, it
 defaults to <EM>{}</EM>, which means that <EM>this_class.__init__</EM> does
 not enforce the value of any argument.
<DT>
<EM>{CLASS: BOOL}</EM> exclude_bases
<DD>Immediate base classes whose
constructors should not be called automatically. If an
immediate superclass of <EM>this_class</EM> is listed in
<EM>exclude_bases</EM>, then we don't automatically call its
constructor. It is assumed that the programmer will call the
constructor manually in <EM>this_class.__init__</EM>. If you do not
specify a value for <EM>exclude_bases</EM>, it will default to <EM>{}</EM>,
which means that the constructor of all immediate super
classes will be called automatically.
</DL>
<H2 ID="Object.Object.init_attrs" CLASS="Method">Object.Object.init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>Initialises existing attributes</P>

<P>
Attributes are only set if they already exist in
 <EM>self.__dict__</EM>. Otherwise, an <EM>AttributeError</EM> exception is
 raised (provided PY_DEBUG_OBJECT=1).</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.Object.possibly_init_attrs" CLASS="Method">Object.Object.possibly_init_attrs(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">attrs</SPAN>)</H2>
<P>None</P>

<P>
Initialises existing attributes, unless those attributes
already exist</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>{STR: ANY}</EM> attrs
<DD>dictionary with attribute name as the keys and
 default values as the values.
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>none</EM>
<DD>
</DL>
<H2 ID="Object.OwnerObject._cleanup_object" CLASS="Method">Object.OwnerObject._cleanup_object(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">object</SPAN>)</H2>
<P>attempt to call cleanup on object</P>

<P>
<STRONG>INPUTS*</STRONG></P>

<DL>

<DT>
<EM>OwnerObject object</EM>
<DD>note: class of object is the expected
class, but _cleanup_object doesn't assume this is correct, nor
does it check whether the object is a subclass of
OwnerObject, only that it is a class instance and that it
has a cleanup attribute
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>reason for error (or None if no error).

</DL>
<H2 ID="Object.OwnerObject.add_grandparent" CLASS="Method">Object.OwnerObject.add_grandparent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">grandparent</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's grandparent (or great-grandparent, etc.)
(Actually, any other reference which needs to be del'ed but not
cleaned up)</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR grandparent</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned" CLASS="Method">Object.OwnerObject.add_owned(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append a new attribute name to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.add_owned_list" CLASS="Method">Object.OwnerObject.add_owned_list(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">owned</SPAN>)</H2>
<P>append new attribute names to the list of owned objects</P>

<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>[STR] owned</EM>
<DD>names of owned attributes
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.cleanup" CLASS="Method">Object.OwnerObject.cleanup(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
method to cleanup circular references by cleaning up 
any children, and then removing the reference to the parent</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.name_parent" CLASS="Method">Object.OwnerObject.name_parent(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">parent=None</SPAN>)</H2>
<P>None</P>

<P>
specify the name of the attribute containing a reference to 
this object's parent.</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR parent</EM>
<DD>name of the parent, or None if none
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="Object.OwnerObject.owned_by" CLASS="Method">Object.OwnerObject.owned_by(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>returns the name of the parent attribute</P>

<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM>
<DD>name of the parent, or None if none

</DL>
<H2 ID="Object.OwnerObject.remove_other_references" CLASS="Method">Object.OwnerObject.remove_other_references(<SPAN CLASS="Argument">self</SPAN>)</H2>
<P>None</P>

<P>
additional cleanup to ensure that this object's references to
its owned objects are the last remaining references</P>
<P>
<STRONG>NOTE:</STRONG> subclasses must call their parent class's 
remove_other_references method, after performing their own duties.
Also, a class inheriting from two OwnerObject classes MUST
define remove_other_references and call both subclasses'
versions</P>
<P>
<STRONG>INPUTS</STRONG></P>
<P>
<EM>none</EM></P>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.close_app_cbk" CLASS="Method">AppState.AppCbkHandler.close_app_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">unexpected=0</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which indicates that the application has 
closed or disconnected from the mediator</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance to be removed
<DT>
<EM>BOOL unexpected</EM>
<DD>1 if the editor broke the connection
without first sending an editor_disconnecting message
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.close_buffer_cbk" CLASS="Method">AppState.AppCbkHandler.close_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has closed a buffer</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the buffer which was closed
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.curr_buff_name_cbk" CLASS="Method">AppState.AppCbkHandler.curr_buff_name_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the current
buffer has changed</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the newly current buffer 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.new_window" CLASS="Method">AppState.AppCbkHandler.new_window(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us of a new window for the 
specified instance</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>BOOL</EM>
<DD>true if window is added

</DL>
<H2 ID="AppState.AppCbkHandler.open_buffer_cbk" CLASS="Method">AppState.AppCbkHandler.open_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has opened a new buffer </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
<DT>
<EM>STR</EM> buff_name
<DD>name of the buffer which was opened
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.rename_buffer_cbk" CLASS="Method">AppState.AppCbkHandler.rename_buffer_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>, <SPAN CLASS="Argument">old_buff_name</SPAN>, <SPAN CLASS="Argument">new_buff_name</SPAN>)</H2>
<P>None</P>

<P>
callback from AppState which notifies us that the application
has renamed a buffer</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance 
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> old_buff_name
<DD>old name of the buffer 
<DT>
<EM>STR</EM> new_buff_name
<DD>new name of the buffer 
</DL>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.resume_cbk" CLASS="Method">AppState.AppCbkHandler.resume_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us that its process has 
resumed after having been suspended </P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>
<H2 ID="AppState.AppCbkHandler.suspend_cbk" CLASS="Method">AppState.AppCbkHandler.suspend_cbk(<SPAN CLASS="Argument">self</SPAN>, <SPAN CLASS="Argument">instance</SPAN>)</H2>
<P>None</P>

<P>
called when the editor notifies us that its process is about
to be suspended</P>
<P>
<STRONG>INPUTS</STRONG></P>

<DL>

<DT>
<EM>STR</EM> instance
<DD>name of the application instance
</DL>
<P>
<STRONG>OUTPUTS</STRONG></P>
<P>
<EM>none</EM>
</P>

<HR>
<TABLE ALIGN="LEFT">
<TR><TD>
  <A HREF="http://validator.w3.org/check/referer" TARGET="validate">
    <IMG BORDER=0 SRC="http://validator.w3.org/images/vh40.gif"
     ALT="Valid HTML 4.0!" HEIGHT=31 WIDTH=88></A>
  <A HREF="http://www.w3.org/Style/CSS/Buttons">
    <IMG ALT="Made with CSS" BORDER=0 WIDTH=88 HEIGHT=31 
     SRC="http://www.w3.org/Style/CSS/Buttons/mwcos"></A>

</TD>
<TD STYLE="padding-left: 10">
  <SPAN CLASS="AUTHOR"></SPAN><BR>
  <SPAN CLASS="VERSION"></SPAN>
</TD>
</TABLE>

</body>
</html>
