; /* ====================================================================
;  * Copyright (c) 2004 Carnegie Mellon University.  All rights
;  * reserved.
;  *
;  * Redistribution and use in source and binary forms, with or without
;  * modification, are permitted provided that the following conditions
;  * are met:
;  *
;  * 1. Redistributions of source code must retain the above copyright
;  *    notice, this list of conditions and the following disclaimer. 
;  *
;  * 2. Redistributions in binary form must reproduce the above copyright
;  *    notice, this list of conditions and the following disclaimer in
;  *    the documentation and/or other materials provided with the
;  *    distribution.
;  *
;  * This work was supported in part by AT&T Labs, CMU Sphinx Speech
;  * Consortium and Clairgrove, LLC.
;  *
;  * THIS SOFTWARE IS PROVIDED BY CARNEGIE MELLON UNIVERSITY ``AS IS'' AND 
;  * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
;  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
;  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY
;  * NOR ITS EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
;  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
;  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
;  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
;  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
;  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;  *
;  * ====================================================================
;  *
;  */
 
(require 'cl)
(require 'mouse)
(require 'listen-events)
(require 'listen-fix)
(require 'listen-support)
(require 'listen-parameters)
(require 'listen-gnu-code-hack)
 
(autoload 'listen-grammar-file-to-dragon
  "listen-grammar")
(autoload 'listen-make-sample "listen-generate-sample")

(defsubst dotted-pair-to-list (pair)
  (list (car pair) (cdr pair)))

(defun listen-proper-sublistp (x y)
  "Is x a link reachable from y, but not y?"
  (and (not (eql x y))
       (progn
	 (while (and y (not (eql x y)) (setq y (cdr y))))
	 y)))

;; hack so that the code will work with Emacs 20
(if (string-match "20" emacs-version)
    (fset 'widget-button-release-event-p 
	  (symbol-function 'button-release-event-p)))

(defvar listen-version ".02")

(defvar listen-initialize-hook nil
  "Functions to be called when listen-mode is turned on.")  

(defvar listen-log nil "If non-nil, print debugging information
in the \"*listen-mode-log*\" buffer.")
(defvar listen-log-frame nil)
(defvar listen-log-buffer nil)
(defun listen-toggle-log ()
  (interactive)
  (cond (listen-log
	 (delete-frame listen-log-frame)
	 (setq listen-log nil))
	((null listen-log)
	 (setq listen-log-buffer (get-buffer-create " *listen-mode-log*"))
	 (with-current-buffer listen-log-buffer
	   (setq truncate-lines t
		 listen-log-frame (make-frame)
		 listen-log t)
	   (set-window-buffer (frame-first-window listen-log-frame)
			      (current-buffer))))))

(defun listen-mode-log (&rest strs)
  (when (and listen-log
	     (not (eq (selected-frame) listen-log-frame)))
    (assert (consp strs))
    (with-current-buffer listen-log-buffer
      (goto-char (point-max))
      (insert (apply 'format (cons (concat (car strs) "\n")
				   (cdr strs))))
      (set-window-point (get-buffer-window listen-log-buffer 'visible) 
			(point-max)))))

(defun listen-and (&rest arguments)
  "Return t if all of the arguments are non-nil; eval all arguments. "
  (catch 'found
    (while arguments
      (unless (pop arguments) (throw 'found nil))) t))

(defun listen-subtract-time (t1 t2)
  "Subtract internal times, do it right for microseconds."
  (let ((res (subtract-time t1 t2))
	(m1 (cond ((nth 2 t1)) (0)))
	(m2 (cond ((nth 2 t2)) (0))))
    (if (< m1 m2)
	(let ((ti (subtract-time res '(0 1 0))))
	  (list (nth 0 ti) (nth 1 ti) (+ 1000000 (- m1 m2))))
      (list (nth 0 res) (nth 1 res) (- m1 m2)))))


;;; GLOBAL VARS

;;; LISTEN EVENT MACRO STUFF
;;; see also listen-pre-command

(defvar listen-do-not-undo-kind-events nil
  "T when a listen command has set the undo field to a non-nil value
and events generated by command are still executing.")

(defvar listen-secondary-events nil
  "T when a listen command is executing secondary events executing.")

(defvar listen-repeating nil
  "T when commands are executing due to a repetition")


;;; LISTEN BUFFER AND FRAME

(defvar vr-listen-buffer nil 
  "Buffer that receives all input from speech recognizer.")

(defvar listen-input-frame nil)
(defvar listen-input-keymap (make-sparse-keymap))
 
(defconst listen-frame-width 130)
;;; Listen undo data structures
;;; these global variables keep track of the most recent events
;;; that are speech undoable 

(defvar listen-recent-records-size 100)
(defvar listen-recent-records 
  (make-vector listen-recent-records-size nil))
(defvar listen-last-index 0 
  "The index of the record holding information about the current event.")
(defvar listen-valid-records 0
  "The number of records in listen-recent-records that are valid.")

(defstruct ListenRecord
  event	      ;; value of last-command-event
  command-keys ;; value of this-command-keys-vector when not listen
  ;; event
  undoable ;; is set according to listen-do-not-undo-kind-events to
  ;; prevent undoing---that is event records with undoable set are
  ;; ignored for undoing purposes (alternatively such events should
  ;; simply not be recorded)
  secondary ;; if this event was issued as a result of a primary
  ;; event (one generated by the user)
  no-replay ;; if this event is not to be replayed during undo,
  ;; such as for mouse events in listen-buffer
  buffer
  new-buffer	 ; the buffer after execution if different from buffer
  point		 ;; point is not saved in window-configuration 
  window-configuration ;; it would be even better to use frame
  ;; configurations, but they are very slow to restore (and also the
  ;; restoration is visually disturbing)
  undo-action ;; usually, the undo-action is nil, and we rely on an
  ;; adaptation of the built-in undo mechanism in Emacs 
  executing-interactive	;; t if this or previous command was interactive and 
  ;; not yet completed (not implemented)
  status ;; status of current command, either 'transparent (if current
  ;; command is a command whose status should be ignored, for example
  ;; if the command is a macro (listen-execute, etc.)) or an
  ;; association list, whose keys could be 'movement (if current
  ;; command is a movement command), 'search (for search commands, the
  ;; value holds the search specification), 'yank (if current command
  ;; is yank), etc
  ;; 
  mouse-position ;; currently unused, the idea is that the mouse
  ;; position should be recorded in this field in the pre-command hook
  ;; and that a spoken command should get its mouse parameters from
  ;; this field, that will enable redoing events even if the mouse has
  ;; been moved since their first occurrence
  marker-before	;; this marker is set by
  ;; listen-set-last to indicate interesting "last" positions near
  ;; text that is modified
  marker-after ;; this marker is set by listen-post-command when
  ;; marker-before has been set
  undo-list	 ;; value of buffer-undo-list (in buffer)
  undo-list-after ;; value of buffer-undo-list (in buffer) after event was executed
  new-undo-list	  ;; same as above but for new-buffer
  new-undo-list-after ;; same as above but for new-buffer
  mark-active	      ;; value of mark-active
  mark		      ;; value of mark
  ;; last-command should be set as well (via this-command) so that
  ;; e.g. previous-line works right (with respect to the temporary
  ;; goal column)
  )

(defvar listen-buffer-undo-list-before)
(make-variable-buffer-local 'listen-buffer-undo-list-before)

(defvar listen-buffer-before (current-buffer)
  "The buffer at the beginning of a command.")

(defvar listen-frame-before (selected-frame))
(defvar listen-frame-before-listen-click nil)

(defvar listen-executing-nullary nil
  "Currently not used")

(defvar listen-last-listen-event nil 
  "The last listen event to be used for repeating the last voice
command; sometimes this variable is bound to a word event.")  

(defvar listen-executing-secondary nil)

(defvar listen-undo-or-redo-event-status 0 
  "This variable is 1 if and only if listen-redo-list is to be reset
to nil in listen-post-command.  The variable may also be 0 (when a
non-primary event is executing) or 2 or 3, see comments in
listen-post-command.")

(defvar listen-redo-list nil
  "The list of events to that will regenerate state at beginning of a
sequence of listen-undo operations. The listen-redo function plays
back the car of this list.")

(defvar listen-set-marker-after nil)

;;; COPYING CONTROL STATUS FROM PREVIOUS

					; (defun listen-copy-control-status ()
					;   (interactive)
					;   (let ((prev-record
					; 	 (aref listen-recent-records 
					; 	       (mod (1- listen-last-index) 
					; 		    listen-recent-records-size))))
					;     (listen-update-current-record  
					;      capitalize-status
					;      (ListenRecord-capitalize-status prev-record))
					;     (listen-update-current-record  
					;      space-status
					;      (ListenRecord-space-status prev-record))
					;     (listen-update-current-record  
					;      phonetic-status
					;      (ListenRecord-phonetic-status prev-record))))

(defun listen-copy-control-status () ())

(defun listen-no-op ()
  (interactive)
  (listen-copy-control-status))

;; LISTEN-MARK
;;; these variables keeps track of mark lists, allowing one to go back
;;; and forth (as opposed to regular Emacs functionality where marks
;;; are lost as you go to them)
(defvar listen-mark-undone-list nil)
(make-variable-buffer-local 'listen-mark-undone-list)
(defvar listen-mark-last-undo-ready nil)
(defvar listen-mark-last-undo-ready-last nil)

;;; RECORDING

(defvar listen-recording nil)

;;; when listen-recording is true, indicate recording by an overlay
;;; applied to the listen-buffer
(defvar listen-recording-overlay (make-overlay 1 0 vr-listen-buffer))
(overlay-put listen-recording-overlay 'face 'underline)
;;; don't use the overlay just now
(delete-overlay listen-recording-overlay)

;;; the number of events that can be recorded is restricted by
;;; listen-recent-records-size
(defvar listen-number-events-recorded nil) 

(defvar listen-ephemeral-recorded-events nil)
(defvar listen-complete-recorded-events nil)

;;; MANUAL UNDOING

(defvar listen-conventional-undoing nil)
(add-hook 'pre-command-hook 'listen-not-active-pre-command)
(add-hook 'post-command-hook 'listen-not-active-post-command)

(defvar listen-buffer-undo-pointer nil)
(make-variable-buffer-local 'listen-buffer-undo-pointer)

;;; FIXING

(defvar listen-no-special-fix-in-minibuffer nil
  "Used in function listen-heard-word.  If value is 'nospace, then
delete all spaces.  If the value is 'hyphen, then insert hyphens instead
of spaces.")

;;; COMMAND LOOP ACCESSORIES

(defvar listen-event-command-words nil
  "The words of the listen command (excluding argument).")

(defvar listen-event-argument-words nil
  "The words that constitute the argument of a listen predicate as
recorded when the event is constructed.")

(defvar listen-last-argument-words nil
  "The argument last supplied to a listen predicate.  It may be the
result of an interactive read-string or it may be obtained from
listen-event-argument-words.")

(defvar listen-event-fix nil)
"For a post predicate, an indication of whether a text insertion
should be fixed (for spacing and capitalization)."

(defvar listen-keypress-count 0)
(defvar listen-keypress-count-autorepeat 0)
(defvar listen-keypress-sub-stat-count 0)
(defvar listen-mouse-click-count 0)
(defvar listen-speech-command-count 0)
(defvar listen-speech-typed-count 0)

(defvar listen-keypress-last nil)
(defvar listen-keypress-time (current-time)) 

;;; This section dedicated to figuring out which key was pressed, and
;;; to maintain counts of keys in listen-stat-keys; Emacs bindings are
;;; really complicated.  function-key-map determines whether keys are
;;; transformed into key codes or other symbols, but not for SPC,
;;; which is never found as 'space.

(defun listen-print-out-final-key ()
  (insert (prin1-to-string
	   (listen-figure-out-final-key (read-event))
	   t)))

(defun listen-figure-out-final-key (x)
  (let ((f-map-image (lookup-key function-key-map (vector x))))
    (single-key-description
     (if (and f-map-image (not (numberp x)))
	 (aref f-map-image 0)
       x))))

(defconst listen-sub-stat-keys-1 '(SPC
				   C-SPC
				   C-S-SPC
				   M-SPC
				   M-S-SPC

				   backspace
				   C-backspace
				   C-S-backspace
				   M-backspace
				   M-S-backspace

				   return
				   C-return
				   C-S-return 
				   M-return
				   M-S-return

				   left right up down 
				   C-S-left C-S-right C-S-up C-S-down
				   C-left C-right C-up C-down
				   M-left M-right M-up M-down
				   M-S-left M-S-right M-S-up M-S-down
 
				   f2 f3 
				   C-f2 C-f3 
				   C-S-f2 C-S-f3 
				   M-f2 M-f3 
				   M-S-f2 M-S-f3

				   tab M-tab C-tab C-S-tab M-S-tab))

(defconst listen-sub-stat-keys-2
  '(\;	 ;; to study dictation v. keyboard
    prior ;; page up
    next  ;; page down
    home  ;; beginning of buffer
    end	  ;; end of buffer
    delete
    insert
    escape
    C-!
    C-@
    C-\#
    C-$
    C-%
    C-^
    C-&
    C-*
    C-\(
    C-\)
    C--
    C-+
    (quote C-\;)
    C-:
    C-/
    C-?
    C-'
    C-.
    C-,
    C-|
    C-\\
    C-\[
    C-\]
    C-{
    C-}

    C-a	;; beginning of line
    C-e	;; end of line
    C-g	;; keyboard quit
    C-j	;; complete
    C-y	;; paste (yank here)
    C-o	;; other window
    C-p	;; up
    C-n	;;  down
    C-b	;; left
    C-f	;; right
    C-x	;; command prefix
    C-c	;; command prefix
    C-v	;; page down
    C-d	;; delete char
    C-h	;; backspace
    C-i	;; tab
    C-k	;; kill-line
    C-l	;; recenter
    C-m	;; enter
    C-q	;; insert special char
    C-r	;; search backwards
    C-s	;; search forwards
    C-t	;; transpose
    C-u	;; prefix
    C-z	;; zap
    C-w	;; cut
    M-!
    M-@
    M-\#
    M-$
    M-%
    M-^
    M-&
    M-*
    M-\(
    M-\)
    M--
    M-+
    M-:
    (quote M-\;)
    M-/
					;    M-?
    (quote M-\')
    M-.
    M-,
    M-|
    M-\\
    M-\[
    M-\]
    M-{
    M-}
    M-a
    M-b
    M-c
    M-d
    M-e
    M-f
    M-g
    M-h
    M-i
    M-j
    M-k
    M-l
    M-m
    M-n
    M-o
    M-p
    M-q
    M-r
    M-s
    M-t
    M-u
    M-v
    M-w
    M-x
    M-y
    M-z
    f4
    f5
    f6
    f7
    f8
    f9
    f10
    f11
    f12))

(defconst listen-stat-keys
  (mapcar (lambda (x) (if (consp x) ;;
			  ;; then (car x) = 'quote
			  (cadr x)
			x))
	  (append listen-sub-stat-keys-1
		  listen-sub-stat-keys-2)))

(defsubst listen-key-to-canonical (key)
  (intern-soft (prin1-to-string 
		(listen-figure-out-final-key key))
	       listen-key-to-canonical))

(defun listen-stat-key-inc (key)
  (let ((s (listen-key-to-canonical key)))
    (set s (1+ (eval s)))))

(defun listen-stat-key-get-clean (key)
  (let ((s (listen-key-to-canonical key)))
    (cond ((get s 'clean))
	  (key))))

(defvar listen-key-to-canonical nil
  "Hash table (obarray) for sorting out the key name mess.")

(unless listen-key-to-canonical
  ;; initialize hash table
  (setq listen-key-to-canonical (make-vector (1- (expt 2 9)) 0))
  (mapcar (function (lambda (key) 
		      (set (intern 
			    (prin1-to-string 
			     (listen-figure-out-final-key key))
			    listen-key-to-canonical)
			   0)))
	  listen-stat-keys)
  (mapcar (function (lambda (key) 
		      (let ((s (listen-key-to-canonical key)))
			(put s 'clean key))))
	  listen-stat-keys))

(defun listen-count-sub-stat ()
  (let ((stat1 0)
	(stat2 0))
    (mapcar (function
	     (lambda (key)
	       (let ((s (listen-key-to-canonical key)))
		 (cond ((member key listen-sub-stat-keys-1)
			(incf stat1 (eval s)))
		       ((member key listen-sub-stat-keys-2)
			(incf stat2 (eval s)))))))
	    listen-stat-keys)
    (list stat1 stat2)))
;;;
				      
(defun listen-last-command-word-list ()
  (mapcar 'prin1-to-car (read-from-string (concat "(" listen-event-command-words ")"))))


;;; Faces
(defconst listen-s-to-w-face 'listen-s-to-w-face)
(make-face 'listen-s-to-w-face)
(set-face-foreground 'listen-s-to-w-face "navy")
(set-face-bold-p 'listen-s-to-w-face t)

(defconst listen-recording-face 'listen-recording-face)
(make-face 'listen-recording-face)
(set-face-background 'listen-recording-face "peach puff")

(defconst listen-argument-face 'listen-argument-face)
(make-face 'listen-argument-face)
(set-face-underline-p listen-argument-face t)

(defconst listen-command-face 'listen-command-face)
(make-face 'listen-command-face)
(set-face-bold-p 'listen-command-face t)

(defconst listen-boundary-face 'listen-boundary-face)
(make-face 'listen-boundary-face)
(set-face-background 'listen-boundary-face "green")

;; Calculate faces

(defconst listen-boundary-command-face 'listen-boundary-command-face)
(make-face 'listen-boundary-command-face)
(set-face-background 'listen-boundary-command-face
		     (face-background 'listen-boundary-face))
(set-face-bold-p 'listen-boundary-command-face 
		 (face-bold-p 'listen-command-face))
(set-face-foreground 'listen-boundary-command-face 
		     (face-foreground 'listen-command-face))
(set-face-background 'listen-boundary-command-face 
		     (face-background 'listen-command-face))

(defun listen-put-face (b e face)
  (if (and (eq (get-text-property b 'face) listen-boundary-face)
	   (eq face 'listen-command-face))
      (setq face listen-boundary-command-face))
  (put-text-property b e 'face face)
  (put-text-property b e 'rear-nonsticky '(face)))

;; DEBUG

(defun listen-debug-message (&rest args)
  (apply 'message args))    

;;; normalization of text input
(defun listen-normalize-text (str)
  ;; Aaargh, subst-char-in-string doesn't work because of multibyte
  ;; issues that defeat me.  This function has as its sole purpose to
  ;; normalize the city name Québec
  (if (string-match "é" str)
      (let ((i (length str)) (rstr ""))
	(while (> i 0)
	  (setq i (- i 1)
		rstr (concat (char-to-string 
			      (if (eq (aref str i) ?é) ?e (aref str i)))
			     rstr)))
	rstr)
    str))

(defun listen-make-alist-for-command (cmd &optional speech)
  (append
   (if speech '((speech . t)))
   (if (get cmd 'nofix) '((nofix . t)))
   (if (get cmd 'nofix-before) '((nofix-before . t)))
   (if (get cmd 'capitalize) '((capitalize . t)))
   (if (get cmd 'phonetic) '((phonetic . t)))))

(defvar listen-preceding-event nil
  "This variable may be dynamically bound to denote the
event preceding the current one that is being parsed. 
If the preceding event is a predicate, the value does not include the
real argument (a dummy \"\" is substituted).")

(defvar listen-following-events nil
  "This variable may be dynamically bound to denote a list of
following events during parsing only.")

;; RECORDING
(defvar listen-recording-overlay (make-overlay 1 1 vr-listen-buffer)) 
(overlay-put listen-recording-overlay 'face listen-recording-face)
(delete-overlay listen-recording-overlay)
(defvar listen-parse-recording nil)
(defsubst listen-indicate-recording (b e)
  (if listen-parse-recording
      (if (overlay-start listen-recording-overlay)
	  (move-overlay listen-recording-overlay 
			(overlay-start listen-recording-overlay)
			e)
	(move-overlay listen-recording-overlay b e))))

;;; WRITTEN/SPOKEN FORM 


(defvar listen-s-to-w-continuous-input nil
  "Set by listen-spoken-to-written.")
(defvar listen-s-to-w-continuous-output nil
  "The position in the result corresponding to
listen-s-to-w-continuous-input.")
(defvar listen-s-to-w-nofix-before)
(defvar listen-s-to-w-nofix)
(defvar listen-s-to-w-capitalize)
(defvar listen-s-to-w-phonetic)
(defvar listen-s-to-w-treat-all t
  "When false, listen-space-word and others are not translated into
their written forms.")
(defvar listen-s-to-w-word nil)

(defun listen-s-to-w-make-face-overlay (b e)   
  ;; (assert (eq (current-buffer) vr-listen-buffer))
  (let ((overl (make-overlay b e vr-listen-buffer)))
    (overlay-put overl 'face 'listen-s-to-w-face)))
 
(defun listen-spoken-to-written (string start make-what)
  "For each pair (SPOKEN WRITTEN) in listen-search-spoken-written,
replace all occurrences of spoken in STRING with WRITTEN.  It is
assumed that each SPOKEN form consists of one or two words made out of
letters or '-' only. Also, listen-spoken-written-continuation is used
to determine sequences of more than one symbols. Set global variable
listen-s-to-w-continuous-input to denote the initial
segment of STRING that corresponds to a continuous string, that is,
one without whitespace. Other listen-s-t-w-... variables are set as well."
  (let* ((result "")
	 events
	 (orig-length (length string))
	 (orig-string string)
	 last-event
	 next-event
	 last-action
	 last-space
	 (last-pos 0)
	 (last-len-string (length string))
	 nofix-before-status		; updated only before event is
					; synthesized from value of nofix-status
	 phonetic-status 
	 nofix-status  ; not updated for 'char and 'special, status is
					; carried through for these
	 capitalize-status 
	 command-words

	 parse-length  ; length of input that corresponds to currently
					; parsed event

	 (last-stamp 0)	; last index into orig-string where listen-ID property
					; was set
	 (make-alist (function
		      (lambda ()
			(append
			 (if nofix-status
			     '((nofix . t)))
			 (if capitalize-status
			     `((capitalize ., capitalize-status)))
			 (if phonetic-status
			     '((phonetic . t)))
			 (if nofix-before-status
			     '((nofix-before . t)))))))

	 (trim-space (function
		      (lambda (string)
			(if last-space
			    (setq string
				  (substring string 0 (1- (length
							   string)))
				  ;; don't do trim-space twice (no
				  ;; that the logic would ever allow
				  ;; it?)
				  last-space nil))
			(if (not nofix-status)
			    ;; \' is end of string
			    (let ((e-end (progn (string-match " *\\'" string)
						(match-beginning 0))))
			      (substring string 0 e-end))
			  string))))

	 (change-last-event-status
	  (function
	   (lambda (status)
	     (if (consp events)
		 (setq events 
		       (cons
			(listen-add-key-value-event (car events)
						    status)
			(cdr events)))))))

	 (stamp-ID 
	  (function
	   (lambda (ID)
	     (if (> (- orig-length (length string))
		    last-stamp)
		 (put-text-property (+ start last-stamp)
				    (+ start 
				       (setq last-stamp
					     (- orig-length 
						(length string))))
				    'listen-ID
				    ID)))))
	 (make-word-event (function
			   (lambda (word parse-length)
			     (let ((ID (incf listen-ID)))
			       (funcall stamp-ID ID)
			       (list 'listen-word
				     word
				     (funcall make-alist)
				     ID)))))

	 (emit-accumulated 
	  (function 
	   (lambda (force &optional ignore-space)
	     ;; Even if (> (length result) last-pos) holds, we must
	     ;; issue an event (so a capi, speece etc at the end is
	     ;; correctly accounted for. That's what 'force' is for.     
	     (let ((end-pos (length result)))
	       ;;or (and last-space
	       ;;			     (not ignore-space)
	       ;;		     (1- (length result)))
	       ;;	(length result))))
	       (when (or (> end-pos last-pos) 
			 force)
		 (when (eq make-what t)
		   (setq events
			 (cons 
			  (funcall make-word-event
				   (let ((str (substring 
					       result
					       last-pos
					       end-pos)))
				     (or (and
					  capitalize-status
					  (capitalize str))
					 str))
				   (- last-len-string (length string)))
			  events))
		   (if (and (consp events) nofix-status)
		       (funcall change-last-event-status
				'nofix)))
		 (setq last-pos (length result)
		       last-len-string (length string)))))))

	 (emit-char-and-phonetic 
	  (function (lambda (&optional do-not-trim-space)
		      (unless do-not-trim-space
			(setq result (funcall trim-space result)))
		      (when (> (length result) last-pos)
			(setq nofix-before-status nofix-status
			      nofix-status nil ; after 'char and
					; 'phonetic we do fix
			      capitalize-status nil
			      ;; Phonetic-status is maintained as individual
			      ;; characters are issued)
			      )
			(funcall emit-accumulated nil))))))

    (if listen-preceding-event    
	(setq last-event listen-preceding-event)
      ;; else, these are the first words to be parsed in this
      ;; utterance
      (if (> listen-valid-records 0)
	  (if (listen-primary-record listen-last-index)
	      (setq last-event
		    (listen-get-record-field 
		     (listen-primary-record listen-last-index)
		     event)))))
 
    (when (and last-event (listen-event-p last-event))
      (let ((alist (listen-event-alist last-event)))
	(setq nofix-status
	      (consp (assq 'nofix alist))
	      capitalize-status
	      (cdr (assq 'capitalize alist))
	      phonetic-status
	      (consp (assq 'phonetic alist)))))
    
    ;; Locate the next word in the string
    (while (> (length string) 0)
      (when (not (save-match-data (string-match " [^ ]+" result)))
	(setq
	 listen-s-to-w-continuous-input 
	 (- orig-length (length string))
	 listen-s-to-w-continuous-output
	 (length result)))
      (catch 'continue
	(if (or 
	     ;; 1/2 and 2 1/2 and such... above
	     (string-match
	      "^\\(\\([0-9]*\\)[ ][0-9]+[/][0-9]+\\)\\([^-]\\|$\\)"
	      string)
	     ;; an abbreviation: Mr., U.S., etc
	     (string-match
	      "^\\(\\(\\w\\)+\\(\\w\\|[.-]\\)*[.]\\)"
	      string)
	     ;; x-ray
	     (string-match  "^\\(x-ray\\)" string)
	     ;; Try to match the alpha chars (without -)
	     ;; The ' is needed for written forms output by the
	     ;; recognizer such as "he's". 
	     (string-match
	      "^\\(\\(\\w\\|[']\\)+\\)\\>" string))
	    ;; We have something that might be a phonetic spelling or
	    ;; a spacing or capitalization word---in either branch of
	    ;; 'or' above, (match-beginning/end 1) holds the interval
	    ;; of first word (potentially hyphenated if it is a spoken
	    ;; form
	    (let* ((b1 (match-beginning 1)) ;; which is 0
		   (e1 (match-end 1)) 
		   (word1 (substring string b1 e1))
		   (word1-dc (downcase word1))
		   (word1-cap-perhaps 
		    (or (and
			 (eq capitalize-status 'capitalize)
			 (capitalize 
			  (substring string 0 e1)))
			(and
			 (eq capitalize-status 'upper)
			 (upcase
			  (substring string 0 e1)))
			(substring string 0 e1)))
		   (b2 (progn
			 (string-match " *\\(x-ray\\|\\(\\w\\)+\\)"
				       string e1)
			 (and (= (match-beginning 0) e1) 
			      (match-beginning 1))))
		   (e2 (if b2 (match-end 0)))
		   (word2 (if b2 (substring string b2 e2)))
		   (parse-with-positive 
		    ;; Consume more input from string, trying to
		    ;; determine whether a listen-number follows.
		    ;; Return word1 multiplied by the value of that
		    ;; positive (or just word1)
		    (function 
		     (lambda (w-form)
		       (let ((positive 
			      (or (and word2
				       (let ((n
					      (listen-argument 
					       listen-numbers
					       (downcase word2)
					       t)))
					 (when n
					   (setq string 
						 (substring string e2)
						 parse-length e2)
					   n)))
				  (and 
				   (setq string (substring string e1)
					 parse-length e1)
				   1)))
			     (subresult ""))
			 (while (> positive 0)
			   (decf positive)
			   (setq subresult (concat subresult w-form)))
			 (or (and capitalize-status
				  (capitalize subresult))
			     subresult)))))
		   (try-special 
		    (function 
		     (lambda ()
		       (save-match-data
			 (when
			     (cond
			      ((string= word1-dc listen-nospace-word)
			       (funcall emit-char-and-phonetic
					(not listen-s-to-w-treat-all))
			       (setq string (substring string e1)
				     parse-length e1
				     phonetic-status t
				     nofix-status t
				     last-space nil)
			       (when (not listen-s-to-w-treat-all)
				 (setq result
				       (concat result "speece ")
				       nofix-status t))
			       t)
			      ((string= word1-dc listen-camel-word)
			       (funcall emit-char-and-phonetic)
			       (setq string (substring string e1)
				     parse-length e1
				     phonetic-status t
				     nofix-status t
				     capitalize-status 'capitalize
				     last-space nil)
			       t)
			      ((string= word1-dc listen-capitalize-word)
			       (funcall emit-char-and-phonetic)
			       (setq string (substring string e1)
				     parse-length e1
				     phonetic-status t 
				     capitalize-status 'capitalize
				     last-space nil)
			       t) 
			      ((string= word1-dc listen-uppercase-word)
			       (funcall emit-char-and-phonetic)
			       (setq string (substring string e1)
				     parse-length e1
				     phonetic-status t 
				     capitalize-status 'upper
				     last-space nil)
			       t)
			      ((and (string= word1-dc listen-newline-word))
			       (funcall emit-char-and-phonetic
					(not listen-s-to-w-treat-all))
			       ;; Side effect warning:
			       ;; parse-with-positive sets both
			       ;; parse-length and string!			       
			       (setq
				nofix-status nil ; normally
				result
				(concat result
					(if listen-s-to-w-treat-all
					    (funcall parse-with-positive
						     "\n")
					  (prog1 "loon "
					    (setq parse-length
						  e1
						  string
						  (substring string
							     e1)
						  nofix-status ; since
					; we now want a space
					; following "loon"
						  t))))
				phonetic-status nil 
				nofix-before-status t
				capitalize-status nil
				last-space nil)
			       (funcall emit-accumulated nil)
			       t)
			      ((and (string= word1-dc listen-space-word))
			       (funcall emit-char-and-phonetic 
					(not listen-s-to-w-treat-all))
			       (setq result 
				     (concat result
					     (if listen-s-to-w-treat-all
						 (funcall parse-with-positive 
							  " ")
					       (prog1 "spooce "
						 (setq parse-length
						       e1
						       string
						       (substring string
								  e1)))))
				     phonetic-status t
				     nofix-status t
				     nofix-before-status t
				     capitalize-status nil
				     last-space nil)
			       (funcall emit-accumulated nil)
			       t))
			   ;; For all special words, mark them
			   (listen-s-to-w-make-face-overlay  
			    (+ start orig-length (- (length string))
			       (- parse-length))
			    (+ start orig-length (- (length string))))
			   (setq last-action 'special)
			   (throw 'continue t))))))
		   
		   (try-phonetic 
		    (function 
		     (lambda ()
		       
		       (let* ((object2 (if word2 (intern-soft 
						  (downcase word2)
						  listen-spoken-written-continuation))))
			 ;; First, is word1 a continuation of a sequence of
			 ;; symbols, or is it followed by a "-", or is the
			 ;; next speech command listen-space-word or is it
			 ;; followed by a positive designation?
			 (if (or phonetic-status
				 ;; a hyphen '-' starts word2
				 (and word2 (> (length word2) 0)
				      (or (eq (aref word2 0) ?-)
					  (string= word2 listen-space-word)
					  (string= word2 listen-nospace-word)))
				 ;; A listen-space-word follows word1 (as
				 ;; event)---remove this case?
				 (and listen-following-events
				      (null word2)
				      (listen-command-event-p 
				       (car listen-following-events))
				      (string= listen-space-word
					       (listen-event-command-words
						(car
						 listen-following-events))))
				 ;; Word2 is itself a spoken form
				 object2
				 ;; Word2 is a ShortTalk numeral
				 (and word2 (string-match listen-numbers-re
							  word2)))
			     (let ((object
				    (intern-soft 
				     word1-dc
				     listen-spoken-written-continuation)))
			       (when object
				 (setq result (concat
					       (funcall trim-space
							result)	
					       (funcall parse-with-positive 
							(eval object)))
				       phonetic-status (eval object)
				       ;; So that a sequence of char
				       ;; and phonetic starting with a
				       ;; phonetic does receive
				       ;; nofix-before-status of t:
				       nofix-status 
				       (or nofix-status
					   (not (member
						 last-action
						 '(phonetic
						   char))))
				       capitalize-status
				       (if (eq capitalize-status
					       'upper)
					   capitalize-status)
				       last-action 'phonetic
				       last-space nil)
				 ;; Don't touch capitalize-status and
				 ;; nofix-status. They are need when these
				 ;; produced characters are eventually
				 ;; emitted
				 (listen-s-to-w-make-face-overlay  
				  (+ start orig-length (- (length string))
				     (- parse-length))
				  (+ start orig-length (- (length string))))

				 (throw 'continue t))))))))
		   (do-word (function (lambda ()
					(cond  ((member last-action '(char phonetic))
						(setq nofix-before-status nofix-status
						      nofix-status nil
						      capitalize-status nil)
						(funcall emit-accumulated nil))
					       ((eq last-action
						    'special)
						(setq result (funcall
							      trim-space result))))
		  
					(setq result (concat result 
							     word1-cap-perhaps)
					      string (substring string e1)
					      parse-length e1)

					(setq last-pos (length result)
					      last-len-string (length string)
					      nofix-before-status nofix-status
					      phonetic-status nil
					      nofix-status nil
					      capitalize-status nil
					      last-action 'word)

					;; generate the word event
					(when (eq make-what t)
					  (setq events
						(cons (funcall make-word-event
							       word1-cap-perhaps
							       parse-length)
						      events)))))))

	      ;; Start of inner let* body

	      ;; Space word, no space word, etc ?
	      (funcall try-special)
		    
	      ;; Otherwise, a phonetic?
	      (funcall try-phonetic)
 
	      ;; Finally, it still no success, then emit this word
	      ;; untreated
	      (funcall do-word)
	      
	      (setq last-space nil))
	  ;; End of let*
	  
	  ;; Else, we are matching a single character
	  
	  (let ((character-as-string (substring string 0 1)))
	    (setq result (concat result 
				 (or (and
				      capitalize-status
				      (capitalize 
				       character-as-string))
				     character-as-string)))
	    (if (not (string= character-as-string " "))
		(setq  last-action 'char
		       capitalize-status 
		       (if (eq capitalize-status
			       'upper)
			   capitalize-status)
		       phonetic-status 
		       (or phonetic-status
			   (string= character-as-string
				    "-"))
		       last-space nil)
	      (setq last-space t))
	    ;; In any case; remember nofix-status, which will become
	    ;; nofix-before-status of next event to be generated
	    (setq string (substring string 1)))))) 

    ;; There might still be chars or phonetic output hanging 
    ;; around
    (funcall emit-char-and-phonetic)

    ;; If still no output, make some 
    (when (null events)
      ;; Generate artificial event (with empty string) to hold
      ;; status information
      (setq nofix-before-status nofix-status)
      (funcall emit-accumulated t))
 
    ;; Post main loop processing
    (setq listen-s-to-w-nofix-before nofix-before-status
	  listen-s-to-w-nofix nofix-status
	  listen-s-to-w-capitalize capitalize-status
	  listen-s-to-w-phonetic (stringp phonetic-status))

    (when (not (string-match " [^ ]+" result))
      (setq
       listen-s-to-w-continuous-input
       (- orig-length (length string))
       listen-s-to-w-continuous-output
       (length result)))
    
    (when (eq make-what t)
      (if nofix-status
	  (funcall change-last-event-status 'nofix))
      (if capitalize-status
	  (funcall change-last-event-status 'capitalize))
      ;; the next two lines are not necessary since
      ;; no single command exists at the present for
      ;; changing phonetic-status alone
      (if phonetic-status
	  (funcall change-last-event-status 'phonetic))
	
      (setq events (reverse events)))
    
    (if (string= result "")
	(setq listen-s-to-w-continuous-input 0
	      listen-s-to-w-continuous-output 0) 
      ;; adjust for possible spaces at the end of the positions
      ;; indicated by the continuous variables
      (let ((s1 (substring orig-string 0 
			   listen-s-to-w-continuous-input))
	    (s2 (substring result 0 
			   listen-s-to-w-continuous-output)))
	(decf listen-s-to-w-continuous-input
	      (- (length s1) (string-match " *$" s1)))
	(decf listen-s-to-w-continuous-output
	      (- (length s2) (string-match  " *$" s2)))))
      
    (setq listen-s-to-w-word result)

    (cond ((eq make-what 'word) 
	   result)
	  (make-what 
	   events)
	  ((null make-what)
	   ;; In this case, ID stamping is missing, TBD
	   (list 'listen-word
		 result
		 nil
		 (incf listen-ID))))))

;;; MAIN PARSING ROUTING TO BE CALLED WHEN SPEECH INPUT HAPPENS

(defun listen-make-do-events-from-text (text start &optional speech)
  "Return a list of events corresponding to TEXT; also, assign them IDs 
and map corresponding positions in the listen buffer to the IDs."
  (assert (eq (current-buffer) vr-listen-buffer))
  (let* (word 
	 number-spaces 
	 (number-spaces-first-time 0)
	 end-word
	 (end-longest-command nil)
	 (words-so-far "")
	 (end-words-so-far start)
	 (remaining-text text)
	 (make-word 
	  (function
	   (lambda (as-what)
	     (let ((ID (incf listen-ID)))
	       (when (> (length words-so-far) 0)
		 (if listen-parse-recording
		     (listen-indicate-recording start end-words-so-far))
		 ;; convert a tab key into a listen-nullary event
		 (cond ((string= words-so-far "\t") 
			(list (list 'listen-nullary
				    (substring words-so-far
					       number-spaces-first-time)
				    ID)))
		       (t (let ((result (listen-spoken-to-written
					 words-so-far
					 start
					 as-what)))
			    (if (and (eq as-what t) (consp result)
				     speech)
				(cons
				 (listen-add-key-value-event (car
							      result)
							     'speech)
				 (cdr result))
			      result))))))))))
    (catch 'exit
      ;; INVARIANT 
      ;;
      ;; text =  current-buffer[start .. (start + |text|}]
      ;;
      ;; remaining-text = current-buffer[end-words-so-far .. (start +
      ;; |text|}]
      ;;
      ;; words-so-far is prefix of text
      ;;
      (while t
	(if (eq (length remaining-text) 0)
	    (throw 'exit (funcall make-word t)))
	;; to look for a command, we really just need the
	;; number of spaces, but calculate the potential first
	;; word as well

	;; determine prefix consisting of stretch of spaces, followed
	;; by stretch of non-spaces (up to a "-" or a "." or "\" or
	;; "/" or ! or ...)  (so that "top-loon" is split into "top-"
	;; and "loon" when "loon" is a command)
	(assert (string-match listen-make-do-re
			      remaining-text))
	(if (null number-spaces)
	    (setq number-spaces-first-time (match-end 1)))
	(setq number-spaces (match-end 1))
	;; what is processed here:
	(setq word (substring remaining-text (match-end 1) (match-end 0)))
	;; the position the first word (or string of non-space characters) end:
	(setq end-word (match-end 0))
	;; the end of longest prefix constituting a command (or nil)
	(setq end-longest-command 
	      (listen-find-longest-command remaining-text number-spaces))
	(if end-longest-command
	    (let* 
		((ID (incf listen-ID))
		 (command-words 
		  (listen-normalize-text
		   (downcase
		    (substring 
		     remaining-text 
		     number-spaces end-longest-command))))
		 (command (intern-soft command-words
				       listen-command-table))
		 (the-rest (substring 
			    remaining-text end-longest-command))
		 (end-in-buffer (+ end-words-so-far
				   end-longest-command))
		 (result-of-rest 
		  ;; Now find out what kind of command
		  (cond  
		   ;; A nullary command
		   ((eq (get command 'type) 'listen-nullary)
		    ;; Label the region in the listen buffer with
		    ;; the ID for the event
		    (put-text-property end-words-so-far
				       end-in-buffer 'listen-ID ID)
		    ;; Then process the rest of the text
		    (let ((listen-preceding-event
			   (list 'listen-nullary command-words 
				 (listen-make-alist-for-command
				  command speech) 
				 ID)))
		      (cons listen-preceding-event
			    (listen-make-do-events-from-text 
			     the-rest end-in-buffer))))

		   ;; A post predicate
		   ((eq (get command 'type) 'listen-post-predicate)
		    ;; We stamp the ID on later for this kind of event

		    ;; Then process the rest of the text.  The element
		    ;; that describes the listen-post-predicate
		    ;; constructed in the list temporary.  It is
		    ;; amended below to include the argument after the
		    ;; recursive call
		    (let ((listen-preceding-event 
			   (list 'listen-post-predicate 
				 command-words 
				 (listen-make-alist-for-command
				  command
				  speech)
				 ID)))
		      (cons  listen-preceding-event
			     (listen-make-do-events-from-text 
			      the-rest end-in-buffer))))
		   ;; A predicate
		   ((eq (get command 'type) 'listen-predicate)
		    ;; The end of the command is the beginning of a
		    ;; command that is not explicitly excluded, so we,
		    ;; are now going to parse the-rest
		    (let ((temp-index 0)
			  (found nil)
			  (temp-rest the-rest)
			  temp-number-spaces
			  temp-next-word
			  temp-end-word
			  temp-end-longest-command)
		      (while (and (not (string= temp-rest ""))
				  (not found))
			(assert (string-match listen-make-do-re
					      temp-rest))
			(setq temp-next-word 
			      (substring temp-rest (match-end 1) 
					 (match-end 0)))
			(setq temp-end-word (match-end 0))
			(assert (> temp-end-word 0))
			(setq temp-number-spaces (match-end 1))
			(cond 
			 ;; This case triggers on the first iteration
			 ;; if at all (not optimal coding!)
			 ((member 
			   command-words
			   listen-predicate-one-argument-command)
			  ;; Then temp-next-word (or rather a possible
			  ;; extension of this word, see below) is the
			  ;; argument of the command
			  (setq found 1))
			 ((let ((regexp (get command
					     'embedded-commands)))
			    ;; embedded commands described by
			    ;; regexp are allowed
			    (and regexp
				 (string-match regexp
					       temp-rest)
				 (eq 0 (match-beginning 0))))
			  ;; Then, munch that embedded command
			  (setq temp-index
				(+ temp-index (match-end 0))
				temp-rest 
				(substring temp-rest
					   (match-end 0)))
			 
			  (listen-s-to-w-make-face-overlay 
			   end-in-buffer
			   (+ end-in-buffer temp-index)))
			
			 ((and (setq temp-end-longest-command 
				     (listen-find-longest-command 
				      temp-rest temp-number-spaces))
			       ;; So, there is a command here! and
			       ;; besides,..
			       (or
				;; it is not the case that the first
				;; word of predicate command indicates
				;; that embedded commands are allowed
				(not
				 (member 
				  (downcase word)
				  listen-predicate-allows-embedded-command-prefix))
				;; but if they're allowed, check that
				;; the particular command is not an
				;; embedded one
				(not
				 (member (downcase temp-next-word)
					 listen-predicate-embedded-command-prefix))))
			  (setq found t))
			 (t
			  ;; else, we found an embedded command, or
			  ;; maybe just a word or some character
			  (if temp-end-longest-command
			      ;; it was a command
			      (setq 
			       temp-index 
			       (+ temp-index
				  temp-end-longest-command)
			       temp-rest 
			       (substring temp-rest
					  temp-end-longest-command))
			    ;; it was just a word, or some characters
			    (setq temp-index
				  (+ temp-index temp-end-word)
				  temp-rest 
				  (substring temp-rest
					     temp-end-word))))))
		      ;; temp-index is now at the end of temp-rest or
		      ;; points to the end of the last thing before
		      ;; the embedded command that was found or points
		      ;; to the thing right after a member of
		      ;; listen-predicate-embedded-command-extension
		      ;; (found = 2)
		      (let* ((recursion-result nil)
			     (argument-spaces-cnt)
			     (argument ;; remove initial spaces from
			      ;; the-rest
			      (substring the-rest 
					 (setq argument-spaces-cnt 
					       (save-excursion 
						 (string-match "^ *" the-rest)
						 (match-end 0)))))
			     written-argument)
			(cond 
			 (found
			  (cond 
			   ((eq found 1)
			    ;; then, we use the embedded command if
			    ;; present or the words that represent a
			    ;; contiguous sequence of characters
			    (if (and
				 (string-match 
				  listen-embedded-commands
				  argument)
				 (= (match-beginning 0) 0))
				;; and embedded command
				(setq written-argument
				      (listen-spoken-to-written
				       (setq argument
					     (substring 
					      argument 0
					      (match-end 0)))
				       (+ end-in-buffer
					  argument-spaces-cnt)
				       'word)
				      temp-index
				      (+ argument-spaces-cnt
					 (match-end 0)))
			      ;; else words that correspond to a
			      ;; contiguous written form
			      (setq written-argument
				    (substring
				     (listen-spoken-to-written
				      argument 
				      (+ end-in-buffer
					 argument-spaces-cnt)
				      'word)
				     0
				     listen-s-to-w-continuous-output)
				    argument
				    (substring 
				     argument 0
				     listen-s-to-w-continuous-input)
				    temp-index
				    (+ argument-spaces-cnt
				       listen-s-to-w-continuous-input))))
			   (found
			    (setq written-argument
				  (let ((listen-s-to-w-treat-all nil))
				    (listen-spoken-to-written
				     (setq argument
					   (substring the-rest 0
						      temp-index))
				     (+ end-in-buffer
					argument-spaces-cnt)
				     'word)))))
			  
			  ;; In either of the found cases, recurse
			  (setq recursion-result
				;; We don't really know the current
				;; event yet since the argument has
				;; not been determined, fake it!
				(let ((listen-preceding-event 
				       (list 'listen-predicate
					     command-words
					     ""
					     (listen-make-alist-for-command
					      command
					      speech)
					     ID)))
				  (listen-make-do-events-from-text 
				   (substring
				    the-rest
				    temp-index) 
				   (+ end-in-buffer
				      temp-index)))))

			 ((not found)
			  (setq written-argument
				(let ((listen-s-to-w-treat-all nil))
				  (listen-spoken-to-written 
				   argument
				   (+ end-in-buffer argument-spaces-cnt)
				   'word)))))
			 
			(put-text-property end-words-so-far
					   (+ end-in-buffer
					      temp-index) 
					   'listen-ID ID)
			 
			(listen-put-face (+ end-in-buffer argument-spaces-cnt)
					 (+ end-in-buffer
					    temp-index)
					 listen-argument-face)
			(cons
			 (list 'listen-predicate
			       command-words 
			       written-argument
			       (cons 
				(cons 'raw-argument argument)
				(listen-make-alist-for-command
				 command
				 speech))
			       ID)
			 recursion-result))))
		   ;; no other types possible
		   (t (assert nil "Listen: the command not recognized")))))

	      (listen-put-face end-words-so-far
			       end-in-buffer
			       listen-command-face)
	      
	      (if listen-parse-recording
		  (if (not (get command 'stop-recording))
		      (listen-indicate-recording end-words-so-far end-in-buffer)
		    (setq listen-parse-recording nil)))
	      
	      (if (and (not listen-parse-recording)
		       (get command 'start-recording))
		  (setq listen-parse-recording t))
	      
	      ;; Find the written form of the preceeding stuff using
	      ;; make-word, and set up listen-following-events for the
	      ;; benefit of listen-spoken-written. Then append the
	      ;; word event together with the the rest (including the
	      ;; command).  If we have a listen-post-predicate, then
	      ;; the situation calls for transmogrifying the word
	      ;; event into the argument of the listen-post-predicate.
	      (cond
	       ((eq (car (car result-of-rest))
		    'listen-post-predicate)
		(throw 
		 'exit 
		 (let* ((listen-following-events
			 ;; do they really matter here
			 result-of-rest)
			(listen-preceding-event
			 (list 'listen-nullary ""
			       '((phonetic . t))
			       'fake)) 
			(word-events
			 (prog1
			     (let* ((listen-preceding-event
				     '(listen-word
				       ""
				       ((phonetic . t))
				       artificial)))
			       (mapcar 
				;; These events have IDs that are
				;; irrelevant. So, replace them.
				(function 
				 (lambda (e)
				   (listen-replace-ID
				    e
				    'artificial)))
				(funcall make-word t)))
			   ;; But, put the ID of the command
			   ;; on the whole interval
			   (put-text-property 
			    start
			    end-in-buffer
			    'listen-ID
			    (listen-event-ID (car result-of-rest)))
			   ;; Make the arguments appear
			   ;; in listen-argument-face
			   (listen-put-face start
					    end-words-so-far
					    listen-argument-face))))
		   (cons
		    ;; Include the argument as a result of calling
		    ;; make-word in the listen-post-predicate
		    (list 'listen-post-predicate 
			  ;; The command words
			  (nth 1 (car result-of-rest)) 
			  ;; The arguments (by side effect)
			  listen-s-to-w-word
			  ;; To fix or not, etc. + bind events
			  (cons (cons 'events word-events)
				(listen-make-alist-for-command 
				 command
				 speech))
			  ;; The ID
			  (listen-event-ID (car result-of-rest)))
		    ;; The result of the recursive call:
		    (cdr result-of-rest)))))
	       ;; For other kinds of commands
	       (t 
		(let ((listen-following-events 
		       result-of-rest)) 
		  (throw 
		   'exit
		   (append (funcall make-word t) result-of-rest))))))
	  (assert (not end-longest-command))
	  ;; Otherwise, we have a word or some string of characters
	  ;; let's try to make a longer word out of it, after all,
	  ;; we are dealing with one utterance here, and that's
	  ;; potential important semantic information, for example
	  ;; if we are using the phrase for a search
	  (assert (> end-word 0))
	  (setq end-words-so-far (+ end-words-so-far end-word))
	  (setq words-so-far (substring text 0 (- end-words-so-far start)))
	  (setq remaining-text (substring remaining-text end-word))
	  (if (string= word "\t")
	      (throw 'exit 
		     (append (funcall make-word t) 
			     (listen-make-do-events-from-text
			      remaining-text end-words-so-far))))
	  ;; go back to start of loop
	  )))))

(defun listen-find-longest-command (text start)
  "Find longest prefix of text, from position start, that contains a
voice command."
  (let ((i start)
	word-end
	(end-longest-command nil))
    (while
	(and
	 ;; This is an awful hack;, but sometimes we need a "." in a
	 ;; command as in "meta X."--so try this first
	 (string-match " ?[A-Z][.]\\| ?-?\\w+" text i)
	 (progn 
	   (setq word-end (match-end 0))
	   (let ((possible-command-words
		  (listen-normalize-text 
		   (downcase (substring text start
					word-end)))))
	     (if (listen-command-words-p possible-command-words)
		 (setq end-longest-command word-end))
	     (setq i word-end)
	     (listen-is-prefix-p possible-command-words)))))
    end-longest-command))

(defmacro listen-update-current-record (field value)
  `(if (aref listen-recent-records listen-last-index)
       (setf (,(intern (concat "ListenRecord-" (symbol-name field)))
	      (aref listen-recent-records listen-last-index))
	     ,value)))

(defmacro listen-get-record-field (record-index field)
  `(if (aref listen-recent-records ,record-index)
       (,(intern (concat "ListenRecord-" (symbol-name field)))
	(aref listen-recent-records ,record-index))))

(defun listen-set-undo-action (action)
  (if  (aref listen-recent-records listen-last-index)
      (setf (ListenRecord-undo-action
	     (aref listen-recent-records listen-last-index)) action)))

(defun listen-undo-with-quit (command-or-sexp)
  (listen-set-undo-action 'keyboard-escape-quit)
  (listen-execute command-or-sexp)) 

;;; COMMAND STATUS

(defun listen-set-command-status (s)
  (setf (ListenRecord-status
	 (aref listen-recent-records listen-last-index)) s))

(defun listen-add-assoc-command-status (ass)
  (assert (consp ass))
  (let ((record  (aref listen-recent-records listen-last-index)))
    (if (eq (ListenRecord-status record) 'transparent)
	(setf (ListenRecord-status record) (list ass))
      (setf (ListenRecord-status record) 
	    (cons ass (ListenRecord-status record))))))

(defun listen-get-assoc-command-status (key)
  (let ((prev-status (listen-previous-command-status)))
    (assoc key prev-status)))

(defun listen-previous-command-status ()
  (let ((i listen-recent-records-size)
	(j (mod (1- listen-last-index) 
		listen-recent-records-size)))
    (while (and (> i 0)
		(eq 'transparent
		    (ListenRecord-status
		     (aref listen-recent-records j))))
      (decf i)
      (setq j (mod (1- j) listen-recent-records-size)))
    (if (> i 0)
	(ListenRecord-status
	 (aref listen-recent-records j)))))

;;; MAKE A LISTEN RECORD

(defun listen-make-record (event)

  (setq listen-last-index 
	(mod (1+ listen-last-index) listen-recent-records-size))

  (let ((marker-before
	 ;; marker designates (point)---
	 ;; try to reuse old marker, since we shouldn't let too many
	 ;; float around
	 (let ((old-record
		(aref listen-recent-records listen-last-index)))
	   (or (and old-record
		    (set-marker 
		     (ListenRecord-marker-before old-record)
		     nil))
	       ;; if not above, then first time, we're creating a
	       ;; record here, so make a new marker
	       (let ((m (make-marker)))
		 (set-marker-insertion-type m nil)
		 m))))
	(marker-after
	 (let ((old-record
		(aref listen-recent-records listen-last-index)))
	   (or (and old-record
		    (set-marker 
		     (ListenRecord-marker-after old-record)
		     nil))
	       (let ((m (make-marker)))
		 (set-marker-insertion-type m nil)
		 m)))))
    (aset listen-recent-records listen-last-index
	  (make-ListenRecord 
	   :event event
	   :command-keys (this-command-keys-vector)
	   :secondary (or executing-kbd-macro
			  listen-do-not-undo-kind-events 
			  listen-secondary-events)
	   :no-replay nil
	   :undoable (not listen-do-not-undo-kind-events)
	   :buffer (current-buffer)
	   :new-buffer nil
	   :point (point)
	   :window-configuration (current-window-configuration)
	   :undo-action nil
	   :executing-interactive nil
	   :marker-before marker-before
	   :marker-after marker-after
	   :undo-list buffer-undo-list
	   :undo-list-after nil
	   :new-undo-list nil
	   :new-undo-list-after nil
	   :mark-active mark-active
	   :mark     (mark t)))
    ;; now insert a boundary (primitive-undo will then unwind at the
    ;; bound as recorded in :undo-list), this changes the behavior of
    ;; the standard undo functions bound to keys
    (setq buffer-undo-list (cons nil buffer-undo-list))))

(defun listen-undo-last-event-record ()
  (interactive)
  (unwind-protect
      (let* ((orig-buffer (current-buffer))
	     (listen-record 
	      (aref listen-recent-records listen-last-index))
	     (undo-action (ListenRecord-undo-action listen-record))
	     (undoable (ListenRecord-undoable listen-record))
	     (buffer (ListenRecord-buffer listen-record))
	     ;; just in case something is screwed up:
	     (max-iterations listen-recent-records-size))
					; (message "undo event:%s 
					; new-after-list:%s 
					; new-list:%s 
					; after-list:%s
					; list:%s
					; undo-action:%s"
					; 	     (ListenRecord-event listen-record)
					; 	     (subseq  (ListenRecord-new-undo-list-after listen-record) 0 5)
					; 	     (subseq  (ListenRecord-new-undo-list listen-record) 0 5)
					; 	     (subseq (ListenRecord-undo-list-after listen-record) 0 5)
					; 	     (subseq (ListenRecord-undo-list listen-record) 0 5)
					; 	     (ListenRecord-undo-action listen-record))
	(when (and undoable (not (eq undo-action 'ignore)))
	  (if undo-action
	      ;; applies to new buffer
	      (progn
		(assert (indirect-function undo-action) t)
		;; this logic is ad hoc; it prevents the calling of
		;; keyboard-quit again after an explicit keyboard-quit
		;; has been issued: vox open, vox quit yields a
		;; sequence of events, where the "vox open" undo-action
		;; does not make sense since the minibuffer was
		;; already disabled by the subsequent command
		(if (or (not (ListenRecord-new-buffer
			      listen-record))
			(eq (ListenRecord-new-buffer listen-record)
			    (current-buffer)))
		    (if (or (not (string-match "^ \\*Minibuf-[0-9]+\\*$"
					       (buffer-name (current-buffer))))
			    (minibuffer-window-active-p (selected-window)))
			(funcall undo-action))))
	    ;; otherwise, undo in new buffer if buffer changed during event
	    ;; this must be reworked based on a more general solution
   	    (when (and (eq (current-buffer)
			   (ListenRecord-new-buffer listen-record))
		       (not (eq buffer-undo-list t))
		       (or (not (string-match "^ \\*Minibuf-[0-9]+\\*$"
					      (buffer-name (current-buffer))))
			   (minibuffer-window-active-p (selected-window)))
		       ;; don't undo anything in listen-buffer, we assume that
		       ;; the only changes that need to be undone are those
		       ;; handled by NaturallySpeaking 
		       (not (eq (current-buffer) vr-listen-buffer)))
	      ;;	      (setq buffer-undo-list 
	      ;;		    (ListenRecord-new-undo-list-after listen-record))
	      (if (and buffer-undo-list
		       (consp buffer-undo-list))
		  (let ((target-undo (ListenRecord-new-undo-list
				      listen-record)))
		    (when (and target-undo (not (eq target-undo t)))
		      (while (listen-proper-sublistp
			      target-undo buffer-undo-list)
			(setq buffer-undo-list 
			      (primitive-undo 1 buffer-undo-list))))))
	      ;; set to buffer as it was before event, but not if
	      ;; that buffer was the minibuffer and it is not
	      ;; active anymore and not if buffer doesn't exist anymore
	      (if (and (buffer-live-p buffer)
		       (or (not (string-match "^ \\*Minibuf-[0-9]+\\*$"
					      (buffer-name buffer)))
			   (minibuffer-window-active-p (selected-window))))
		  (set-buffer buffer))))
	  (if (buffer-live-p buffer)
	      (with-current-buffer buffer
		(when
		    (and (eq buffer (current-buffer))
			 (or (not (string-match "^ \\*Minibuf-[0-9]+\\*$"
						(buffer-name buffer)))
			     (minibuffer-window-active-p (selected-window)))
			 (not (eq (current-buffer) vr-listen-buffer)))
		  (if (and buffer-undo-list
			   (consp buffer-undo-list))
		      (let ((target-undo (ListenRecord-undo-list
					  listen-record)))
			;; (when target-undo
					; (setq buffer-undo-list 
					; 			      (or;; try to use the recorded value
					; 			       (ListenRecord-undo-list-after listen-record)
					; 			       ;; otherwise, if this function is called as part
					; 			       ;; of current event, then list-after is not yet 
					; 			       ;; recorded (of course), so use buffer-undo-list
					; 			       buffer-undo-list))
			(when (and target-undo (not (eq target-undo t)))
			  (while (listen-proper-sublistp
				  target-undo buffer-undo-list)
			    (setq buffer-undo-list (primitive-undo 1 buffer-undo-list))
			    (decf max-iterations))
			  (assert (not (eq max-iterations 0)))))))))
	  ;; )
	  ;; assert: undo-action is not 'ignore
	  ;; both for explicit undo and implicit undo:
	  (set-window-configuration 
	   (ListenRecord-window-configuration listen-record))
	  ;; hack we don't like cursor in inactive minibuffer (when
	  ;; undoing a 'vox-quit' after 'vox-open'
	  (if (or (not (buffer-live-p buffer))
		  (and (buffer-live-p buffer) 
		       (string-match "^ \\*Minibuf-[0-9]+\\*$"
				     (buffer-name buffer))
		       (not (minibuffer-window-active-p
			     (selected-window)))))
	      ;; lacking better information, reselect orig-buffer in
	      ;; window (which is hopefully still there)
	      (pop-to-buffer orig-buffer)
	    ;; in case undo-list was not used (because of explicit undo record)
	    (when (ListenRecord-mark-active listen-record)
	      (push-mark (ListenRecord-mark listen-record) nil t)
	      (setq deactivate-mark nil))
	    (goto-char (ListenRecord-point listen-record)))))
    ;; in all cases, even when undo-action is a quit
    (setq listen-last-index 
	  (mod (1- listen-last-index)
	       listen-recent-records-size))))

;;; UNDOING, SIMULATING THE CONVENTIONAL WAY
    
(defun listen-conventional-undo ()
  "Undo using built-in undo function."
  (interactive)
  (setq listen-conventional-undoing t) ; so that post-command doesn't reset 
					; listen-buffer-undo-pointer
  (if listen-mark-last-undo-ready-last
      ;; last thing done was a last-mark operation
      (progn
	(assert (consp listen-mark-undone-list))
	(goto-char (car listen-mark-undone-list))
	(push-mark (point) t)
	(setq  listen-mark-undone-list (cdr listen-mark-undone-list))
	(setq listen-mark-last-undo-ready (consp
					   listen-mark-undone-list))
	(message "Undo set mark operation!"))
    (let ((last-command nil)
	  done)
      (message "Undo text change!")
      (if (not listen-buffer-undo-pointer)
	  (setq listen-buffer-undo-pointer buffer-undo-list)
	;; otherwise, we're already manually undoing, trick undo
	;; function into also thinking so through dynamic binding
	(setq last-command 'undo))
      (loop until done do 
	    (let* ((ptr listen-buffer-undo-pointer)
		   (next-op (progn
			      (while (and ptr (not (consp (car ptr)))) 
				(setq ptr (cdr ptr)))
			      (and ptr (car ptr))))
		   (text-to-delete (and next-op
					(numberp (car next-op))
					(numberp (cdr next-op))))
		   ;; purpose of text-to-delete-is-single-alpha ?
		   (text-to-delete-is-single-alpha
		    (and text-to-delete
			 (= (1+ (car next-op)) (cdr next-op))
			 (string-match "\\w"
				       (buffer-substring 
					(car next-op)
					(cdr next-op))))))
	      (if  (and (boundp 'cua-mode) (cua-mode))
		  (cua-undo)
		(undo))
	      (setq done (or (not text-to-delete-is-single-alpha)
			     (null pending-undo-list))
		    listen-buffer-undo-pointer pending-undo-list
		    last-command 'undo))))))
    
;;; UNDO word

(defun listen-undo ()
  (interactive)
  (cond 
   ((null listen-mode) (listen-conventional-undo))
   (t ; listen-mode is on
    ;; first, undo the keyboard event that invoked this interactive
    ;; function
    (assert (> listen-valid-records 0))
    (listen-undo-last-event-record) 
    (decf listen-valid-records)
    ;; second, if event that is to be undone is a listen event, then
    ;; update the transcription buffer
    (let ((do-more t))
      (while do-more
	(setq do-more nil)
	(let* ((primary-index (listen-primary-record listen-last-index))
	       (index listen-last-index))
	  (cond ((and primary-index (> listen-valid-records 0))
		 (while 
		     (prog1
			 (not (eq index primary-index))
		     (let ((event (listen-get-record-field
				   listen-last-index event)))
		       (if (listen-do-event-p event)
			   (with-current-buffer vr-listen-buffer
			   ;; if something is selected, ignore that
			   (end-of-buffer)
			   (setq deactivate-mark t)
			   (when (> (point-max) (point-min))
			     ;; there might be transcribed words in 
			     ;; vr-listen-buffer to delete
			     ;; note that some words may correspond to
			     ;; events that were not executed (if
			     ;; previous events aborted)
			     (let ((ID (listen-event-ID event))
				   ID-in-buffer
				   (start-boundary t)
				   found)
			       (when
				   (not (member 
					 ID 
					 '(recorded repeat artificial)))
				 (while (and start-boundary
					     (not found))
				   (setq start-boundary 
					 (previous-single-property-change 
					  (point)
					  'listen-ID
					  (current-buffer) 
					  (point-min)))
				   (when start-boundary
				     (setq ID-in-buffer
					   (get-text-property 
					    start-boundary
					    'listen-ID))
				     (setq found
					   (eq ID ID-in-buffer))
				     (when (not found)
				       (goto-char start-boundary)
				       ;; break loop if at start and not found
				       (if (eq start-boundary 1)
					   (setq start-boundary nil)))))
				 (if found
				     (delete-region start-boundary
						    (point-max))
				   (error "EmacsListen: undo speech event")))))))
		     ;; in any case, carry out the undoing (message
		     ;; "undo index %s" (listen-get-record-field index
		     ;; event)) cons to redo list
		     (when (and (not (listen-get-record-field 
				      listen-last-index secondary))
				(not
				 (listen-get-record-field 
				  listen-last-index
				  no-replay)))
		       (if (listen-event-p event)
			   (setq listen-redo-list
				 (cons
				  (list
				   (listen-replace-ID ; so that it is
					; clear that the
					; event is not a
					; speech event
				    (listen-get-record-field 
				     listen-last-index
				     event)
				    'recorded))
				  listen-redo-list))
			 ;; it was a key sequence or some mouse event
			 (let ((keys (listify-key-sequence
				      (listen-get-record-field
				       listen-last-index command-keys))))
			   (setq listen-redo-list
				 (cons
				  keys
				  listen-redo-list)
				 do-more 
				 (and (null (cdr keys))
				      (integerp (car keys))
				      (string-match "\\w" 
						    (string (car
							     keys)))))))
		       (message "%s" listen-redo-list))
		     ;; now carry out the undo
		     (listen-undo-last-event-record)
		     (decf listen-valid-records)
		     (setq index (mod (1- index)
				      listen-recent-records-size)))))
		 ;; communicate to post-command-hook function that this event
		 ;; should not reset listen-redo-list
		 (setq listen-undo-or-redo-event-status 0))
		(t
		 (message "EmacsListen: could not undo!")))))))))

(defun listen-redo () 
  (interactive)
  ;; see usage in listen-pre-command and listen-post-command
  (setq listen-undo-or-redo-event-status 3)
  (if (consp listen-redo-list)
      (let ((events (car listen-redo-list)))
	(setq unread-command-events 
	      (append unread-command-events
		      events)
	      listen-redo-list (cdr listen-redo-list)))
    (message "Nothing to be redone")))

;;; REPETITION STUFF

(defun listen-start-recording () 
  (interactive)
  ;; see listen pre and post-command hooks for more logic governing repetition
  (setq listen-recording  (mod (1+ listen-last-index) 
			       listen-recent-records-size))
  (listen-set-undo-action
   (function (lambda ()
	       (setq listen-recording nil)
	       (delete-overlay listen-recording-overlay))))
  (setq listen-number-events-recorded 0)
  (move-overlay listen-recording-overlay 
		(point) (1- (point)) vr-listen-buffer))

(defun listen-stop-recording ()
  (interactive)
  ;; see listen pre and post-command hooks for more logic governing repetition
  (when listen-recording
    (setq listen-complete-recorded-events
	  (listen-get-events listen-recording))
    (setq listen-ephemeral-recorded-events nil)
    (setq listen-recording nil)))

(defun listen-get-events (r)
  "Gather events from record number r to the second last event."
  ;; first, recurse 
  (let ((tail 
	 (if (eq (mod (1+ r) listen-recent-records-size)
		 (listen-primary-record listen-last-index))
	     ;; don't count the event that current command
	     ;; is bound to
	     nil 
	   (listen-get-events 
	    (mod (1+ r)
		 listen-recent-records-size)))))
    ;; second, into the record r if it is primary 
    (if (not (listen-get-record-field r secondary))
	(cons  
	 ;; these events are not associated with the
	 ;; original event IDs, so call them, say, 'recorded
	 (listen-replace-ID 
	  ;;fish out the event of the record indicated by r 
	  (listen-get-record-field r event)
	  'recorded)
	 tail)
      tail)))

(defun listen-repeat-recording ()
  (interactive)
  (listen-set-command-status 'transparent)
  ;; check to see whether we're currently recording something
  (if listen-recording
      (let* ((events (listen-get-events listen-recording)))
	(setq listen-ephemeral-recorded-events events)
	(setq listen-complete-recorded-events events)))
  (setq listen-recording nil
	this-command last-command
	listen-mark-last-undo-ready listen-mark-last-undo-ready-last
	listen-repeating t
	listen-parse-recording nil)
  ;; only repeat recording if there is one
  (when listen-complete-recorded-events
    (let ((n (listen-number-argument)))
      (setq unread-command-events
	    (cons 'listen-end-of-repetition unread-command-events))
      (while (> n 0)
	(decf n)
	(listen-execute-events-as-macro listen-complete-recorded-events)))))

(defun listen-repeat-last-command-or-recording (&optional prefix-argument)
  (interactive "p") 
  (listen-set-command-status 'transparent)
  (setq this-command last-command
	listen-mark-last-undo-ready listen-mark-last-undo-ready-last
	listen-repeating t
	listen-parse-recording nil)
  (when (or listen-recording listen-ephemeral-recorded-events
	    listen-last-listen-event)
    (let ((n (or
	      (and (listen-event-p last-command-event)
		   (listen-number-argument))
	      (abs (or prefix-argument 1)))))
      (setq unread-command-events
	    (cons 'listen-end-of-repetition unread-command-events))
      ;; the while loop below results in a sequence of the form 
      ;;
      ;; (e listen-primary-events e listen-primary-events ..
      ;; .. listen-end-of-repetition)
      ;;
      ;; with listen-secondary-events being t only for the first
      ;; occurrence of e, instead listen-repeating is true throughout
      ;; the interval during which the sequence is executed
      ;;
      (while (> n 0)
	(decf n)
	;; if we're in the process of recording something, then replay
	;; that 
	(cond (listen-recording
	       (let* ((events (listen-get-events listen-recording)))
		 (setq listen-recording nil)
		 (setq listen-ephemeral-recorded-events events)
		 (setq listen-complete-recorded-events events)
		 ;; play them back as secondary events
		 (message "Repeat what's just recorded")
		 (listen-execute-events-as-macro listen-ephemeral-recorded-events)))
	      ;; otherwise, if events were already recorded, use them provided
	      ;; that the preceding event was also a playback event
	      (listen-ephemeral-recorded-events
	       (message "Repeat just recorded again")
	       (listen-execute-events-as-macro listen-ephemeral-recorded-events))
	      ;; otherwise, replay the last listen event
	      (listen-last-listen-event
	       (message "Repeat: %s" (if (nth 1 listen-last-listen-event)
					 (nth 1 listen-last-listen-event)
				       listen-last-listen-event))
	       (listen-execute-events-as-macro
		(list (listen-replace-ID
		       listen-last-listen-event
		       'repeat)))))))))

(defun listen-go-again-by-voice ()
  (interactive)  
  ;; the last listen event is the one that invoked this function
  (when listen-last-listen-event 
    (message "Repeat: %s" (if (nth 1 listen-last-listen-event)
			      (nth 1 listen-last-listen-event)
			    listen-last-listen-event))
    (setq listen-repeating t)
    (setq unread-command-events
	  (cons 'listen-end-of-repetition unread-command-events))
    (let ((n (listen-number-argument)))
      (while (> n 0)
	(decf n)
	(listen-execute-events-as-macro
	 (list (listen-replace-ID
		listen-last-listen-event
		'repeat)))))))

;;; vr-listen-buffer mouse stuff

(defun listen-go-away-from-listen-frame ()
  (with-current-buffer vr-listen-buffer
    (goto-char (point-max))
    (setq mark-active nil)
    (set-window-point 
     (frame-first-window listen-input-frame)
     (point-max))
    (if listen-frame-before-listen-click
	(raise-frame
	 listen-frame-before-listen-click))))

(define-key listen-input-keymap 
  [down-mouse-1] 
  (function
   (lambda (e)
     (interactive "e")
     (listen-update-current-record no-replay t)
     (listen-set-undo-action 'ignore)
     (when (not (eq listen-frame-before
		    listen-input-frame))
       (setq listen-frame-before-listen-click
	     listen-frame-before))
     (call-interactively 'mouse-drag-region))))

(defun listen-buffer-mouse-up (e)
  (interactive "e")
  (listen-update-current-record no-replay 't)
  (listen-set-undo-action 'ignore)
  (let ((pos (event-end e))
	beg end)
    (when (windowp (posn-window pos))
      (select-window (posn-window pos))
      (when (numberp (posn-point pos))
	(goto-char (posn-point pos))
	(let ((w-thing (bounds-of-thing-at-point 'word)))
	  (if w-thing
	      (setq beg (car w-thing) end (cdr w-thing))
	    (if (< (point) (point-max))
		(setq beg (point) end (1+ (point))))))))
    (when beg
      (goto-char beg)
      (push-mark end t t)
      (setq mark-active t))))

(defun listen-buffer-drag (e)
  (interactive "e")
  (listen-update-current-record no-replay 't)
  (call-interactively 'mouse-set-region))

(define-key listen-input-keymap [mouse-1] 
  ;; the built in code in mouse.el expects that mouse-1 be bound to a
  ;; symbol
  'listen-buffer-mouse-up)

(define-key listen-input-keymap [double-mouse-1] 
  'listen-buffer-mouse-up)

(define-key listen-input-keymap [triple-mouse-1] 
  'listen-buffer-mouse-up)

(define-key listen-input-keymap [drag-mouse-1]
  'listen-buffer-drag)

;;; listen-mode 
(defvar listen-commands-loaded nil)

(defvar listen-pre-hook nil "Since EmacsListen is emulating a command
loop (such as when commands are issued in listen-heard-nullary), we
use this hook to attach functions that usually go on pre-command-hook.
This should be reconsidered perhaps.")  

(defvar listen-post-hook nil "Not implemented.")

(defun listen-mode-turn-on ()

  ;; EmacsListen assumes highlighting mechanism 
  ;; (essential for 'choose' command, for example)
  (transient-mark-mode 1)

  (unless listen-commands-loaded
    (listen-read-commands)
    (setq listen-commands-loaded t))

  (run-hooks 'listen-initialize-hook)

  (if (and (boundp 'cua-mode) cua-mode
	   (not delete-selection-mode))
      (add-hook 'listen-pre-hook 'cua--pre-command-handler))

  (if delete-selection-mode
      (add-hook 'listen-pre-hook 'delete-selection-pre-hook))
  
  (setq listen-valid-records 0)

  (remove-hook 'pre-command-hook 'listen-not-active-pre-command)
  (remove-hook 'post-command-hook 'listen-not-active-post-command)

  (add-hook 'pre-command-hook 'listen-pre-command)
  (add-hook 'post-command-hook 'listen-post-command)
  (if (not (assq 'listen-mode minor-mode-alist))
      (setq minor-mode-alist (cons '(listen-mode listen-mode-line)
				   minor-mode-alist)))
  ;; redirect voice input to the listen buffer
  (let ((old-frame (selected-frame)))
    (setq vr-listen-buffer 
	  (get-buffer-create "*EmacsListen*"))
    (setq listen-input-frame
	  (make-frame 
	   `((width . ,listen-frame-width)
	     (left . 0) (top . 0) (height . 2) 
	     (cursor-type . bar) (vertical-scroll-bars . nil)
	     (tool-bar-lines .  nil)
	     (minibuffer . nil) (menu-bar-lines . 0)
	     (has-modeline-p . nil))))
    (set-window-buffer (frame-first-window listen-input-frame) 
		       vr-listen-buffer)
    (with-current-buffer vr-listen-buffer
      (setq truncate-lines t) 
      (use-local-map listen-input-keymap)
      (auto-fill-mode -1)
      (vr-add-to-activation-list (current-buffer)))
    (raise-frame old-frame)))

(defun listen-mode-turn-off ()
  (if listen-transcript-file (listen-clear))
  (remove-hook 'pre-command-hook 'listen-pre-command)
  (remove-hook 'post-command-hook 'listen-post-command)
  (add-hook 'pre-command-hook 'listen-not-active-pre-command)
  (add-hook 'post-command-hook 'listen-not-active-post-command)
  (setq vr-buffer nil)
  (delete-frame listen-input-frame))

(defun listen-save-transcript-timer ()
  ;; then make the transcript
  (listen-clear)
  ;; run timer again, in 24 hours
  (run-at-time (* 24 60 60) nil 'listen-save-transcript-timer)
  (message "Transcript added"))

(when (not listen-save-transcript-no-timer)
  ;; don't run more timers if this file is evaluated again
  (setq listen-save-transcript-no-timer t)
  (run-at-time listen-save-time nil 'listen-save-transcript-timer))


(defun listen-kill-emacs ()
  (if vr-listen-buffer
      (listen-clear)))

(add-hook 'kill-emacs-hook 'listen-kill-emacs)

(defvar listen-mode ()
  "Mode variable for listen mode.")

(defvar listen-mode-line 
  '(" EL")
  "Mode-line contributation by EmacsListen.")


(defun listen-mode (&optional arg)
  "Listen mode (not a traditional mode)"
  (interactive "P")
  (setq listen-mode
        (if (null arg)
            (not listen-mode)
          (> (prefix-numeric-value arg) 0)))
  (if listen-mode
      (progn
	;; vr-mode hack 
	(modify-frame-parameters (selected-frame) '((name . "emacs")))
	(vr-mode 1)
	(listen-mode-turn-on)
	(vr-activate-buffer vr-buffer))
    (vr-mode -1)
    (listen-mode-turn-off)))


(defun listen-text-to-xml (str)
  (mapconcat (function
	      (lambda (x) 
		(cond ((eq x ?&)
		       "&amp		;")
		      ((eq x ?<)
		       "&lt;")
		      ((eq x ?\")
		       "&quot;")
		      ((char-to-string x)))))
	     str
	     ""))

(defun listen-clear ()
  (interactive)
  (when vr-listen-buffer
    (with-current-buffer vr-listen-buffer
      (goto-char (point-min))
      (when t
	;; turn "&", "<", and ">" into XML entities
	(goto-char (point-min))
	(while (search-forward "&" nil t)
	  (replace-match "&amp;" nil t))
	(goto-char (point-min))
	(while (search-forward "<" nil t)
	  (replace-match "&lt;" nil t))
	(goto-char (point-min))
	;;  make a header
	(insert "\n" "<session date=\""
		(current-time-string)  "\">\n")
	(insert "<stat "
		"keypress-count=\"" 
		(number-to-string listen-keypress-count)"\" "
	      
		"keypress-count-autorepeat=\""
		(number-to-string listen-keypress-count-autorepeat)"\" " 

		"keypress-sub-stat-count=\""
		(number-to-string listen-keypress-sub-stat-count)"\" "

		(let ((sub-stat (listen-count-sub-stat)))
		  ;; it better be the case that (nth 0 sub-stat)+(nth 1
		  ;; sub-stat) is the same as listen-keypress-sub-stat-count
		  (concat "keypress-sub-stat-1-count=\""
			  (number-to-string (nth 0 sub-stat))
			  "\" "
			  "keypress-sub-stat-2-count=\""
			  (number-to-string (nth 1 sub-stat))
			  "\" "
	      
			  "sub-stat-percentage=\"" 
			  (number-to-string (/ (* 100 listen-keypress-sub-stat-count) 
					       (1+ listen-keypress-count)))
			  "\" "
				   
			  "sub-stat-1-over-sub-stat=\""
			  (number-to-string (/ (* 100 (nth 0 sub-stat)) 
					       (1+
						listen-keypress-sub-stat-count)))
			  "\" "))

		"mouse-click-count=\"" 
		(number-to-string listen-mouse-click-count)"\" "

		"speech-command-count=\"" 
		(number-to-string listen-speech-command-count)
		"\" "

		"speech-typed-count=\"" 
		(number-to-string listen-speech-typed-count) 
	      
		"\"/>\n")
	(insert "<stat-detail>\n")
	(mapc (lambda (key)
		(let ((s (listen-key-to-canonical
			  key)))
		  (insert 
		   "<key name=\""
		   (listen-text-to-xml
		    (prin1-to-string 

		     (let ((s (listen-stat-key-get-clean
			       key)))
		       (if (consp s)
			   ;; then (car s = 'quote)
			   (cadr s)
			 s))))
		   "\" value=\""
		   (number-to-string (eval s))
		   "\"/>\n")
		  (set s 0)))
	      listen-stat-keys)
	(insert "</stat-detail>\n")
	(setq listen-keypress-count 0
	      listen-keypress-count-autorepeat 0
	      listen-keypress-sub-stat-count 0
	      listen-mouse-click-count 0
	      listen-speech-command-count 0
	      listen-speech-typed-count 0)
	;; second, make each command recognized appear on a line of its
	;; own and designate the command by inserting 3 dollar signs at
	;; the beginning
	(forward-char -1)
	(let ((non-command-last nil))
	  (while (not (eobp))
	    ;; look for non-whitespace
	    (when (re-search-forward "[^ \n\t]" (point-max) 0)
	      (forward-char -1)
	      (cond ((member (get-text-property (point) 'face)
			     '(listen-boundary-command-face
			       listen-command-face))
		     (when non-command-last
		       (insert "\n"))
		     (insert "<command name=\"")
		     (delete-horizontal-space)
		     ;; make the command begin with a lower case letter
		     (downcase-region (point) (1+ (point)))
		     ;; skip over all characters that have the 'bold
		     ;; property while having the same ID
		     (let ((pos-ID
			    (set-marker (make-marker)
					(next-single-property-change (point)
								     'listen-ID 
								     nil
								     (point-max))))
			   (pos-face
			    (next-single-property-change (point)
							 'face
							 nil
							 (point-max))))
		       ;; ignore change from 'listen-boundary-bold to 'bold
		       (if (eq (get-text-property pos-face 'face)
			       'bold)
			   (setq pos-face
				 (next-single-property-change pos-face
							      'face
							      nil
							      (point-max))))
		       (goto-char (min pos-ID pos-face))
		       (delete-horizontal-space)
		       (insert-before-markers "\">")
		       (goto-char pos-ID)
		       (setq pos-ID nil)
		       (re-search-forward "\\=[ \n\t]*")
		       (delete-horizontal-space)
		       (insert "</command>\n"))
		     (setq non-command-last nil))
		    (t ;; skip over non-white space
		     (forward-char 1)
		     (setq non-command-last t))))))
	(insert "</session>")
	(append-to-file (point-min) (point-max)
			listen-transcript-file)
	(delete-region (point-min) (point-max))))))
 
;;; MIC STATE CHANGE

					;(defun vr-mic-state-change ()
					;  (if (or (string= state "off") (string= state "sleep"))
;; consider resetting *listen* buffer
					;      nil
					;    ))

(defun listen-execute-event-macro (macro)
  "Execute MACRO as secondary events that will not replayed.
See `listen-execute-events-as-macro'."
  (listen-execute-events-as-macro (listify-key-sequence macro)))

(defun listen-execute-events-as-macro (events &optional not-undoable) 
  "Execute EVENTS as secondary events that will not be redone or
replayed."
  (if (null (listen-get-record-field listen-last-index status))
      ;; then we'll assume that is correct to regard the current
      ;; event as a transparent one
      (listen-update-current-record status 'transparent))
  ;; inject-t events
  (if not-undoable
      ;; events are still recorded, but marked as undoable
      (progn (setq unread-command-events
		   (append events
			   '(listen-undoable-kind-events)
			   '(listen-primary-events)
			   unread-command-events))
	     (setq listen-do-not-undo-kind-events t)
	     (setq listen-secondary-events t))
    ;; do record events as secondary so that they can be undone,
    ;; but not redone
    (setq unread-command-events
	  (append events
		  '(listen-primary-events)
		  unread-command-events))
    (setq listen-secondary-events t)))

(defun listen-simple-execute (command-or-sexp)
  "Execute COMMAND-OR-SEXP.  Return true if and only if an error is
not signaled during execution?.  Use execute-kbd-macro to execute a
macro."
  (assert (or (commandp command-or-sexp) 
	      (consp command-or-sexp)))
					;  (condition-case nil
					;      (progn 

  (if (consp command-or-sexp)
      (eval command-or-sexp)
    (if (symbolp command-or-sexp)
	(call-interactively command-or-sexp)
      (error "EmacsListen: listen-simple-execute problem")))
  ;; execute-kbd-macro is problematic, it appends to the end of
  ;; unread-command-events
  ;; (execute-kbd-macro command-or-sexp)))
  )

(defun listen-execute (command-or-sexp)
  "This function must be bound to an event that is recorded; the
status of this event record is set to 'transparent if COMMAND-OR-SEXP
is not an sexp or a symbol, that is, if command-or-sexp is a
command---which leads to the insertion of events in
unread-command-events."

  (assert (or (commandp command-or-sexp) 
	      (consp command-or-sexp)))
  (save-match-data
    (if (symbolp command-or-sexp)
	(call-interactively command-or-sexp)
      (if (consp command-or-sexp)
	  (eval command-or-sexp)
	(listen-execute-event-macro command-or-sexp)))))

(defun listen-call-interactively-with-position (command &optional as-symbol
							words)
  (if (null words)
      (setq words (listen-event-command-words last-command-event)))
  (let ((position (listen-argument listen-common-positions
				   words t)))
    (if position
	(let ((the-string
	       (listen-simple-do-at-position 
		'(let ((result 
			(bounds-of-a-number-of-things-at-or-near-point
			 'symbol 1)))
		   (buffer-substring (car result) (cdr result)))
		words)))
	  (if the-string
	      (funcall command
		       (if as-symbol (intern the-string) the-string))))
      (call-interactively command))))


(defun listen-select-window (window-instruction &optional no-split)
  "Select the window indicated by WINDOW-INSTRUCTION.  If NO-SPLIT is
true, then don't split windows (they were already split, presumably)."
  (assert (member window-instruction
		  '(present previous next delete split full)))
  (cond ((eq window-instruction
	     'previous)
	 ;; get another other window (or create such a window) --
	 ;; so, test: one window?
	 (if (and (not no-split)
		  (eq (selected-window)
		      (next-window nil 'ignore nil)))
	     ;; if so, create another window
	     (listen-split-window))
	 (select-window (previous-window nil 'ignore nil)))
	((eq window-instruction
	     'next)
	 ;; get another other window (or create such a window) -- so,
	 ;; test: one window?
	 (if (and (not no-split) 
		  (eq (selected-window)
		      (next-window nil 'ignore nil)))
	     ;; if so, create another window
	     (listen-split-window)
	   ;; else, go to the next one
	   (select-window (next-window nil 'ignore nil))))
	((and (eq window-instruction 'split) (not no-split))
	 (listen-split-window))
	((eq window-instruction 'delete)
	 (delete-window)) 
	((eq window-instruction 'full)
	 (delete-other-windows)) 
	(t ;; then, keep window configuration
	 nil)))

(defun listen-execute-and-window-manage (action &optional
						stay-in-original)

  "Eval ACTION, then manage window is afterwards so that the window
displaying the effect of action is in accordance with window
management instructions."
  (save-match-data
    (let ((old-window (selected-window))
	  (old-point (window-point))
	  (old-buffer (current-buffer))
	  (old-start (window-start))
	  (old-numb-windows (count-windows))
	  (window-instruction
	   (listen-argument listen-window-management))
	  window-info-alist)
      ;; gather information about what is shown in the windows of the
      ;; frame
      (loop for windw being the windows do
	    (setq window-info-alist 
		  (cons (cons windw 
			      (list
			       (window-buffer windw)
			       (window-point windw)
			       (window-start windw)))
			window-info-alist)))
      ;; now, to the action
      (eval action)    
      ;; try to find out what the effect was: if a window is new or
      ;; shows a new buffer, then that's probably the effect --
      ;; otherwise, assume that the effect is in the current buffer
      (let ((effect-window
	     (loop for windw being the windows do
		   (let ((old-buffer-shown 
			  (car-safe
			   (cdr-safe 
			    (assoc windw window-info-alist)))))
		     (if (null old-buffer-shown)
			 (return windw)
		       (if (not (eq old-buffer-shown (window-buffer windw)))
			   (return windw))))))
	    (new-numb-windows (count-windows)))
	(if (null effect-window)
	    (setq effect-window (selected-window)))
	(select-window effect-window)
	;; register what the effect is
	(let  ((result-point (point))
	       (result-buffer (current-buffer))
	       (result-start (window-start)))
	  ;; now, find the real window where the effect should be shown
	  ;; this may delete the effect window, don't split further if
	  ;; if windows were just split
	  (select-window old-window)
	  (listen-select-window window-instruction
				(> new-numb-windows old-numb-windows))
	  ;; 
	  (cond 
	   ( ;; the effect window wasn't deleted by listen-select-window
	    ;; and it's different from the selected window?
	    (and (window-live-p effect-window)
		 (not (eq (selected-window) effect-window)))

	    (let ((window-info 
		   (cdr-safe (assoc effect-window window-info-alist))))
	      ;; if the effect-window was not created for the occasion,
	      ;; ie, it existed before
	      (when window-info
		(set-window-buffer (selected-window) result-buffer)
		(set-window-start (selected-window) result-start)
		(set-window-point (selected-window) result-point)
		(set-window-buffer effect-window (nth 0 window-info))
		(set-window-point effect-window (nth 1 window-info))
		(set-window-start effect-window (nth 2 window-info)))
	      ;; otherwise, effect-window window was created by action,
	      ;; and we won't do anything
	      ))
	   ( ;; the effect window wasn't deleted by listen-select-window
	    ;; and it's the same as selected-window, but another window
	    ;; was created by window instruction (split)
	    (and (window-live-p effect-window)
		 (> (count-windows) new-numb-windows))
	    ;; redisplay old-window in selected-window
	    (set-window-buffer (selected-window) old-buffer)
	    (set-window-start (selected-window) old-start)
	    (set-window-point (selected-window) old-point))
	   ( ;; the effect window was deleted?
	    (not (window-live-p effect-window))
	    ;; then, the effect-window is old-window (which was deletet)
	    ;; restore in selected-window
	    (set-window-buffer (selected-window) result-buffer)
	    (set-window-start (selected-window) result-start)
	    (set-window-point (selected-window) result-point))))
	(if (and stay-in-original (window-live-p old-window))
	    (select-window old-window))))))

(defun listen-thing-at-position-call-and-window-manage 
  (command &optional
	   stay-in-original
	   thing-is-symbol)
  ;; put the combinator together, uuh, backquote notation doesn't work
  ;; because of the optional argument, so this code has gotten a
  ;; little hard to read (and I don't like macros)
  (listen-undo-with-quit
   (list 'listen-execute-and-window-manage
	 (list 'quote 
	       (list
		'listen-call-interactively-with-position 
		(list 'quote command) 
		thing-is-symbol))
	 stay-in-original)))

(defun listen-call-at-position-and-window-manage (command &optional
							  stay-in-original)
  (listen-execute-and-window-manage
   (list
    'listen-simple-do-at-position
    (list 'quote command))
   stay-in-original))

(defun listen-window-manage-and-execute (action &optional stay-in-original)
  (let ((old-window (selected-window))
	(window-instruction
	 (listen-argument listen-window-management)))
    (listen-select-window window-instruction)
    (listen-execute action)
    (if (and stay-in-original (window-live-p old-window))
	(select-window old-window))))

;; not currently used
(defun listen-identifier-spoken-to-written (string)
  "Treat string according to embedded 'speece' and 'coomel' commands."
  (with-temp-buffer
    (insert string)
    (goto-char (point-min))
    (replace-string (concat " " listen-nospace-word " ") "") 
    (goto-char (point-min))
    (while (search-forward (concat listen-camel-word " ") nil t)
      (delete-region (match-beginning 0) (match-end 0))
      (capitalize-word 1))
    (buffer-string)))
      
(defun listen-call-interactively-identifier (command-or-sexp)
  "COMMAND-OR-SEXP is called interactively.  If the last command is a
listen command that contain argument words, then these words are
converted into a word event."
  (interactive)   
  (when 
      (and (listen-command-event-p last-command-event)
	   (> (length listen-event-argument-words) 0))
    (let (argument)
      ;; This code works only if the embedded command is the whole argument
      (if (and (string-match 
		listen-embedded-commands
		listen-event-argument-words)
	       (and (= (match-beginning 0) 0)
		    (= (match-end 0) (length listen-event-argument-words))))
	  (if (string-match listen-yank-word listen-event-argument-words)
	      ;; this was an embedded yank command
	      (let* ((number (listen-extract-number listen-event-argument-words))
		     (text (current-kill (1- number) t)))
		(setq argument (or text "")))
	    ;; this was an embedded command that references
	    ;; something at a common position
	    (let* ((source-region 
		    (listen-region-near-common-position-this-or-that 
		     listen-event-argument-words))
		   (source-buffer 
		    (listen-buffer-near-common-position-this-or-that
		     listen-event-argument-words)))
	      (setq argument
		    (with-current-buffer source-buffer
		      (buffer-substring (car source-region)
					(cdr source-region))))))
	(setq argument listen-event-argument-words))
      (listen-execute-events-as-macro
       (list
	(list 'listen-word 
	      ;; remove spaces (?  = 32)
	      (remove* ?  argument)
	      nil 'artificial)
	(list 'return)))))
  ;; in all cases, execute command-or-sexp
  (let ((listen-no-special-fix-in-minibuffer 'no-space))
    (listen-execute command-or-sexp)))

(defun listen-primary-record (r)
  "Locate earliest primary record before R."
  (let ((done nil)
	(index r)
	(j listen-valid-records))
    (while (and (not done)
		(> j 0))
      (setq done 
	    (not (listen-get-record-field index secondary)))
      (when (not done) 
	(setq index 
	      (mod (1- index) listen-recent-records-size))
	(decf j)))
    (if done index)))

;;; FACE FOR MARK 

(make-face 'listen-mark-face-1)
(set-face-background 'listen-mark-face-1 "goldenrod")
(set-face-stipple 'listen-mark-face-1 nil)
(make-face 'listen-mark-face-2)
(set-face-background 'listen-mark-face-2 "dark goldenrod")
(make-face 'listen-mark-face-minus-1)
(set-face-background 'listen-mark-face-minus-1 "pink")
(make-face 'listen-last-face)
(set-face-background 'listen-last-face "light green")


(defvar listen-mark-overlay-1)
(setq-default listen-mark-overlay-1 nil)
(make-variable-buffer-local 'listen-mark-overlay-1)
(defvar listen-mark-overlay-1-previous nil)

(defvar listen-mark-overlay-2)
(setq-default listen-mark-overlay-2 nil)
(make-variable-buffer-local 'listen-mark-overlay-2)
(defvar listen-mark-overlay-2-previous nil)

(defvar listen-mark-overlay-minus-1)
(setq-default listen-mark-overlay-minus-1 nil)
(make-variable-buffer-local 'listen-mark-overlay-minus-1)
(defvar listen-mark-overlay-minus-1-previous nil)

(defvar listen-last-overlay)
(setq-default listen-last-overlay nil)
(make-variable-buffer-local 'listen-last-overlay)
(defvar listen-last-overlay-previous nil)

(defmacro listen-update-display-common-position (overlay p face)
  ;; p is (buffer position) or nil
  (let ((overlay-previous (intern (concat (symbol-name overlay)
					  "-previous")))) 
    `(cond ((cdr ,p)
	    (with-current-buffer (car ,p)
	      (when (null ,overlay)
		(setq ,overlay (make-overlay 1 0))
		(overlay-put ,overlay 'face (quote ,face)))
	      (cond ((and (< (cdr ,p) (point-max))
			  (= (char-after (cdr ,p)) ?\n)
			  (or (/= (point) (cdr ,p))
			      (not (eq (window-buffer) (car ,p))))
			  (> (cdr ,p) (point-min))
			  (/= (char-before (cdr ,p)) ?\n))
		     ;; at end of non-empty line, then fake another
		     ;; space that follows and color last character and
		     ;; space---this is a hack
		     (move-overlay ,overlay
				   (1- (cdr ,p))
				   (cdr ,p)
				   (car ,p))
		     (overlay-put ,overlay 'after-string " "))
		    ((and (eq (window-buffer) (car ,p))
			  (eq (point) (cdr ,p)))
		     ;; don't show overlay if point is already there
		     (delete-overlay ,overlay))
		    ;; move overlay to color position
		    (t
		     (move-overlay ,overlay
				   (cdr ,p)
				   (1+ (cdr ,p))
				   (car ,p))
		     (overlay-put ,overlay 'after-string nil)))
	      (if (and (not (eq ,overlay ,overlay-previous)) ,overlay-previous)
		  (delete-overlay ,overlay-previous))
	      (setq ,overlay-previous ,overlay))) 
	   ((and (not (cdr ,p)) ,overlay)
	    (delete-overlay ,overlay)))))

;;; HOOKS

(defun listen-record-to-be-made ()
  (not
   (or	    
    (eq this-command 'listen-redo)
    (listen-redo-event-p last-command-event)
    (member last-command-event 
	    '(listen-primary-events
	      listen-undoable-kind-events
	      listen-end-of-repetition)))))

(defun listen-not-active-pre-command ()
  (setq listen-conventional-undoing nil))

(defun listen-pre-command () 
  (listen-mode-log "%s,
    this-command: %s,
    cur-buf: %s"
		   last-command-event this-command (current-buffer))

  ;; if the post-command-hook has lost listen-post-command, then add
  ;; it again

  (add-hook 'post-command-hook 'listen-post-command)
  
  (setq listen-conventional-undoing nil)
  (setq listen-set-marker-after nil)
  (assert (and (>= listen-undo-or-redo-event-status 0)
	       (<= listen-undo-or-redo-event-status 2)))

  (unless (> listen-undo-or-redo-event-status 1)
    (setq listen-undo-or-redo-event-status 1)) 

  ;; assume this command is not a request to undo last-mark
  (setq listen-mark-last-undo-ready nil)

  (setq listen-buffer-before (current-buffer))

  (setq listen-buffer-undo-list-before buffer-undo-list)

  ;; always check whether the listen-undoable-kind-events event has
  ;; been lost from unread-command-events queue when the
  ;; variable listen-do-not-undo-kind-events has been set to true
  (if (and listen-do-not-undo-kind-events
	   (not 
	    (member 'listen-undoable-kind-events unread-command-events)))
      ;; this also takes care of the case when the current event is in
      ;; fact listen-undoable-kind-events 
      (setq listen-do-not-undo-kind-events nil))

  ;; to a similar thing for listen-secondary-events flag
  (if (and listen-secondary-events
	   (not (member 'listen-primary-events unread-command-events)))
      (setq listen-secondary-events nil))

  ;; to a similar thing for listen-end-of-repetition
  (if (and listen-repeating
	   (not (member 'listen-end-of-repetition unread-command-events)))
      (setq listen-repeating nil))
  
  ;; we only want to record this event if it was not artificially
  ;; generated
  (if (listen-record-to-be-made)
      (progn
	(listen-make-record last-command-event)
	(if (< listen-valid-records listen-recent-records-size)
	    (incf listen-valid-records))
	; (when (and
; 	       (not listen-secondary-events)
; 	       (not executing-kbd-macro))
; 	  ;; then we have a primary event 

; 	  (cond ((or (symbolp last-command-event)
; 		     (integerp last-command-event))

; 		 (when (and (eq last-command-event
; 				listen-keypress-last)
; 			    (let ((ti (listen-subtract-time
; 				       (current-time)
; 				       listen-keypress-time)))
; 			      (and (eq (nth 0 ti) 0)
; 				   (eq (nth 1 ti) 0)
; 				   (< (nth 2 ti) 300000))))
; 		   (incf listen-keypress-count-autorepeat))
; 		 (setq listen-keypress-time (current-time))
; 		 (setq listen-keypress-last last-command-event)
; 		 (incf listen-keypress-count 
; 		       (length (this-command-keys-vector)))
; ;;; consider all keys that constitute vector
; 		 (mapc (function 
; 			(lambda (e)
; 			  (when (listen-key-to-canonical e)
; 			    (incf listen-keypress-sub-stat-count)
; 			    (listen-stat-key-inc e))))
; 		       (this-command-keys-vector)))
; 		((listen-command-event-p last-command-event)
; 		 (incf listen-speech-command-count)
; 		 ;; add the length of the argument to the
; 		 ;; listen-speech-typed-count (and add 1 to account
; 		 ;; for the enter key
; 		 (if (eq (listen-event-type last-command-event)
; 			 'listen-predicate)
; 		     (incf listen-speech-typed-count
; 			   (1+ (length (nth 2 last-command-event))))))
; 		((listen-word-event-p last-command-event)
; 		 (incf listen-speech-typed-count
; 		       ;; account for the space usually inserted
; 		       ;; before the words
; 		       (1+ (length (nth 1 last-command-event)))))
; 		((widget-button-release-event-p last-command-event)
; 		 (incf listen-mouse-click-count)))
; 					; 	  (message
; 					; 	   "Keypress: %s (Auto: %s SubStat: %s) SubStat%%: %s Mouse: %s Speech command: %s Speech typed: %s" 
; 					; 	   listen-keypress-count 
; 					; 	   listen-keypress-count-autorepeat
; 					; 	   listen-keypress-sub-stat-count
; 					; 	   (/ (* 100 listen-keypress-sub-stat-count) 
; 					; 	      (1+ listen-keypress-count))
; 					; 	   listen-mouse-click-count 
; 					; 	   listen-speech-command-count
; 					; 	   listen-speech-typed-count)
; 					; 	  (message "event: %s" last-command-event)
; 					; 	  
; 	  )
	
	(if listen-secondary-events
	    (listen-copy-control-status))
	
	(when listen-recording
	  ;; if there is no more room, then stop recording 
	  (if (> listen-number-events-recorded listen-recent-records-size)
	      (progn 
		(setq listen-recording nil)
		(delete-overlay listen-recording-overlay)
		(message "Recording: no more space"))
	    ;; otherwise, just keep counting
	    (incf listen-number-events-recorded)))))
  (if listen-executing-nullary
      (message
       "Listen: grammar problem, previous listen command not
nullary!"))) 

(defun listen-not-active-post-command ()
  ;; for purpose of listen-conventional-undoing
  (if (and (not listen-repeating) (not listen-conventional-undoing))
      ;; reset undo-pointer, so that listen-conventional-undo will
      ;; start afresh --we don't attempt to mess around
      ;; with this variable for non-recordable events
      (setq listen-buffer-undo-pointer nil)))

(defun listen-post-command ()
  (listen-mode-log " post! current-buf:%s\, listen-buffer-before:%s" 
		   (current-buffer) listen-buffer-before)
  
  (add-hook 'pre-command-hook 'listen-pre-command)
  ;; if abort-recursive-edit by voice, then recover
  ;; thrown away commands 
  (when (and listen-discarded-input (eq last-command-event ?)) 
    (assert (listp listen-discarded-input))
    (setq unread-command-events listen-discarded-input
	  listen-discarded-input nil))
  
  (cond
   ((eq listen-undo-or-redo-event-status 1)
    ;; we have a primary event that is not undo or redo
    (setq listen-redo-list nil))
   ((> listen-undo-or-redo-event-status 1)
    ;; listen-undo-or-redo-event-status is 2 (if executing redo
    ;; event) or 3 (if executing key bound to redo)
    (decf listen-undo-or-redo-event-status)))
  
  ;; if focus leaving listen-input-frame
  (if (and (eq listen-frame-before listen-input-frame)
	   (not (eq (selected-frame) listen-input-frame)))
      ;; remove selection in listen-input-frame and goto end
      (listen-go-away-from-listen-frame))

  ;; remember this frame as frame before next event is considered
  (setq listen-frame-before (selected-frame))

  ;; display the position of mark
  (let ((m (cons (current-buffer) (mark t))))
    (listen-update-display-common-position 
     listen-mark-overlay-1 m listen-mark-face-1))
  ;; and, if the mark is active also the second-last value of mark
    
  (let ((m2 (cons (current-buffer) 
		  (and mark-active mark-ring (car mark-ring)))))
    (listen-update-display-common-position
     listen-mark-overlay-2 m2 listen-mark-face-2)) 
  
  ;; display the position of mark that was last popped
  (let ((minus-m (cons (current-buffer) (car-safe listen-mark-undone-list))))
    (listen-update-display-common-position 
     listen-mark-overlay-minus-1 minus-m listen-mark-face-minus-1))
  ;; display the position called last (loost) 
  (let ((p (listen-last-buffer-position))) 
    (listen-update-display-common-position 
     listen-last-overlay p listen-last-face))

  (setq listen-mark-last-undo-ready-last
	listen-mark-last-undo-ready) 

  ;; we should really make listen-confirm work through the usual
  ;; command loop, not the read-events function; this would involve
  ;; temporarily rebinding certain keys --and modifying the meaning of
  ;; "spooce" and "goink"; also use listen-confirm-remaining-events to
  ;; store remaining events, those that are to be confirmed
  ;;  (unless (eq this-command 'listen-confirm)
  ;;     (setq listen-confirm-remaining-events nil))

  (when (vectorp (aref listen-recent-records listen-last-index))
    ;;	(message "listen-post event:%s  current-buf:%s
    ;;	 listen-buffer-before:%s" last-command-event
    ;;	 (current-buffer) listen-buffer-before)
    ;; (message "Status %s this-command: %s last-command: %s"
    ;; 		 (ListenRecord-status (aref listen-recent-records
    ;; 					    listen-last-index))
    ;; 		 this-command last-command)
    ;; 	(message "space status %s" (ListenRecord-space-status 
    ;;	(aref listen-recent-records listen-last-index)))
    (if (not (eq (current-buffer) listen-buffer-before))
	;; make sure to refresh listen-buffer-undo-list-before
	;; in old buffer when buffer changed (this variable
	;; is set in (current-buffer) by pre-hook
	(if (buffer-live-p listen-buffer-before)
	    (with-current-buffer listen-buffer-before
	      (setq listen-buffer-undo-list-before buffer-undo-list))))
    (when (listen-record-to-be-made)
      ;; be careful: post-command hooks are called before
      ;; recursive edits, the "when" tries to restrict to
      ;; situations that are normal


	      
      (when (eq listen-buffer-before 
		(ListenRecord-buffer  
		 (aref listen-recent-records listen-last-index)))

	(if listen-set-marker-after
	    (set-marker (ListenRecord-marker-after
			 (aref listen-recent-records
			       listen-last-index))
			(point)))

	(if (buffer-name listen-buffer-before)
	    (with-current-buffer listen-buffer-before
	      ;;		      (setq buffer-undo-list (cons nil buffer-undo-list))
	      (setf (ListenRecord-undo-list-after
		     (aref listen-recent-records listen-last-index))
		    buffer-undo-list)))
	(when (not (eq listen-buffer-before (current-buffer)))
	  (setf (ListenRecord-new-buffer
		 (aref listen-recent-records listen-last-index))
		(current-buffer))
	  (setf (ListenRecord-new-undo-list
		 (aref listen-recent-records listen-last-index))
		listen-buffer-undo-list-before)
	  ;; try always to make buffer-undo-list non-empty (so we can
	  ;; safely implement listen-undo-last-event-record by
	  ;; a sublist test)
	  (unless buffer-undo-list
	    (setq buffer-undo-list '(nil)))
	  (setf (ListenRecord-new-undo-list-after
		 (aref listen-recent-records listen-last-index))
		buffer-undo-list))
	(if (and (not listen-repeating) (not listen-conventional-undoing))
	    ;; reset undo-pointer, so that listen-conventional-undo will
	    ;; start afresh --we don't attempt to mess around
	    ;; with this variable for non-recordable events
	    (setq listen-buffer-undo-pointer nil))))))


;;; Turn tab character \t into a command
(listen-make-command "\t" 'listen-nullary '(execute-kbd-macro '[tab]))

					;(listen-make-command "file" nil nil)


;;; when you load a .evg file, it will go into listen-grammar mode.
(setq auto-mode-alist
      (cons '("\\.elg$" . listen-grammar-mode)
	    auto-mode-alist))
(autoload 'listen-grammar-mode "listen-grammar"
  "Major mode for editing EmacsListen grammar files." t)


(defun listen-generate-html-from-transcript (&optional buffer)
  "Convert the current text in the *EmacsListen* buffer to HTML."
  (interactive)
  (if (null buffer)
      (setq buffer vr-buffer))
  (save-excursion
    (set-buffer buffer)
    (insert "<html><body>\n")
    (goto-char (point-min))
    (while (not (eobp))
      (cond 
       ((eq (get-text-property (point) 'face) 'listen-boundary)
	(insert "<span style=\"color:gray; \"> |</span>")
	(goto-char (1+ (point))))
       ((eq (get-text-property (point) 'face) 'bold)
	(insert "<span style=\"font-weight: bold;\">")
	(goto-char (or (next-single-property-change (point) 'face)
		       (point-max)))
	(insert "</span>"))
       ((goto-char (1+ (point))))))
    (insert "\n</html></body>\n")))

					; (listen-generate-html-from-transcript)

;;; GLOBAL EVENT DECLARATIONS

(global-set-key [listen-primary-events]
		;; basically, this event does not need to do anything,
		;; since we're doing something really awfully
		;; complicated in the command hooks (namely telling
		;; them that a sequence of secondary events is over)
		;; there is one problem, however, sometimes the
		;; behavior of a key depends on the previous command,
		;; so attempt to preserve this information (an example
		;; is the use of temporary-goal-column in simple.el)
		(function (lambda () (interactive)
			    (setq this-command last-command
				  listen-mark-last-undo-ready
				  listen-mark-last-undo-ready-last) 
			    ;; it's not needed to update status of
			    ;; current record to 'transparent, since
			    ;; listen-primary-events are not
			    ;; registered 
			    
			    )))


(define-key isearch-mode-map [listen-primary-events]
  (lookup-key global-map '[listen-primary-events])) 

;; listen-end-of-repetition
(global-set-key [listen-end-of-repetition]
		(lookup-key global-map '[listen-primary-events])) 

(define-key isearch-mode-map [listen-end-of-repetition]
  (lookup-key global-map '[listen-primary-events])) 

;; listen-undoable-kind-events

(global-set-key [listen-undoable-kind-events]
		;; this event signifies the end of events that are to
		;; be not undone (because they are generated by a
		;; primary event with an explicit undo action)
		(function (lambda () (interactive)
			    (setq this-command last-command
				  listen-mark-last-undo-ready listen-mark-last-undo-ready-last)
			    (listen-update-current-record status
							  'transparent)
			    )))

(define-key isearch-mode-map [listen-undoable-kind-events]
  (lookup-key global-map '[listen-undoable-kind-events]))


;; don't stay in listen-input-frame, this event is useful to insert
;; for corrections so that focus is assured to be in the last frame
;; that was not the listen-input-frame
(global-set-key [listen-go-away-from-listen-frame]
		(function (lambda () (interactive)
			    (message "listen-go-away-from-listen-frame")
			    (select-frame listen-input-frame)
			    (set-buffer vr-listen-buffer)
			    (goto-char (point-max))
			    (setq deactivate-mark t)
			    (set-window-point 
			     (frame-first-window listen-input-frame) 
			     (point-max))
			    (if listen-frame-before-listen-click
				(raise-frame listen-frame-before-listen-click)))))

(define-key isearch-mode-map [listen-go-away-from-listen-frame]
  (lookup-key global-map '[listen-go-away-from-listen-frame]))

;;; go back from a temporary excursion simulating a mouse click
(global-set-key [listen-return-from-click-excursion]
		(function 
		 (lambda (e) 
		   (interactive "e") 
		   (listen-update-current-record
		    status 'transparent)
		   (let ((w (nth 1 e))
			 (p-marker (nth 2 e)))
		     (select-window  w)
		     (goto-char p-marker)
		     (set-marker p-marker nil)))))

(global-set-key [listen-return-from-excursion]
		(function 
		 (lambda (e) 
		   (interactive "e") 
		   (listen-update-current-record
		    status 'transparent)
		   (let ((b (nth 1 e))
			 (p-marker (nth 2 e)))
		     (set-buffer b)
		     (goto-char p-marker)
		     (set-marker p-marker nil)))))

(global-set-key [listen-execute-now]
		(function 
		 (lambda (e) 
		   (interactive "e")
		   (listen-update-current-record
		    status 'transparent)

		   (setq this-command last-command
			 listen-mark-last-undo-ready
			 listen-mark-last-undo-ready-last)
		   (save-match-data
		     (let ((command-or-sexp (nth 1 e)))
		       (if (symbolp command-or-sexp)
			   (call-interactively command-or-sexp)
			 (if (consp command-or-sexp)
			     (eval command-or-sexp)
			   (listen-execute-event-macro
			    command-or-sexp))))))))

(global-set-key [listen-click] 'listen-click-1)

(defun listen-last-buffer-position ()
  "Return (buffer . pos), the place where something last was affected
by a voice command and which is different from point. Return nil if no
such place exists"
  (let ((i listen-last-index)
	(no-loop listen-valid-records)
	(found nil)) 
    (while (and (not found) 
		(not (eq no-loop 0))
		(aref listen-recent-records i))
      (let ((marker-bef
	     (listen-get-record-field i marker-before))
	    (marker-aft (listen-get-record-field 
			 i marker-after)))
	(if (or (marker-position marker-bef)
		(marker-position marker-aft))
	    (let ;; Try marker-aft, if it fails, then marker-bef
		((m (if (and (marker-position marker-aft)
			     (not 
			      (and
			       (eq (current-buffer) 
				   (marker-buffer marker-aft))
			       (eq (point) (marker-position
					    marker-aft)))))
			marker-aft
		      ;; Else
		      (if (and (marker-position marker-bef)
			       (not
				(and
				 (eq (current-buffer)
				     (marker-buffer marker-bef))
				 (eq (point) (marker-position
					      marker-bef)))))
			  marker-bef))))
	      (if m
		  (let*  ((m-buffer (marker-buffer m))
			  (m-pos (marker-position m))
			  (m-win (get-buffer-window m-buffer)))
		    (if (and (buffer-live-p m-buffer)
			     (or (not (window-minibuffer-p m-win))
				 (minibuffer-window-active-p m-win)))
			(setq found (cons m-buffer m-pos)))))))
	(when (not found)
	  (setq i (mod (1- i) listen-recent-records-size))
	  (decf no-loop))))
    found))


;;;
(defun listen-load-grammar ()
  (interactive)
  (listen-grammar-file-to-dragon) 
  (listen-read-commands))

(provide 'listen-mode)


